This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.adminjs/
  bundle.js
  entry.js
src/
  admin/
    index.js
  config/
    index.js
    swagger.js
  db/
    init.js
    migrate_paisa.sql
    schema.sql
  middleware/
    auth.js
    errorHandler.js
    rateLimiter.js
    shopScope.js
    validator.js
  models/
    InvoiceAggregate.js
  routes/
    attendance.js
    auth.js
    categories.js
    customers.js
    home.js
    invoices.js
    ops.js
    payments.js
    photos.js
    products.js
    purchases.js
    settings.js
    setup.js
    vendors.js
  services/
    home/
      businessPulse.js
      homeSnapshot.service.js
      homeSnapshot.types.js
      momentum.js
      primaryAction.js
      recentActivity.js
      riskSummary.js
    attendanceService.js
    auditService.js
    backupService.js
    categoryService.js
    customerService.js
    fileService.js
    invoiceService.js
    logService.js
    paymentService.js
    productService.js
    purchaseService.js
    sequenceService.js
    settingsService.js
    shopService.js
    userService.js
    vendorService.js
  utils/
    calculator.js
    checksum.js
    logger.js
    logger.test.js
    sanitize.js
    upload.js
    uuid.js
  server.js
storage/
  backups/
    swipe_backup_2026-01-05T16-31-10-613Z.zip
  photos/
    .gitkeep
  0ea049fd8cacc9cd095a75321afe477b.png
.env.production
.gitignore
integration.md
NODE_VERSION_REQUIRED.md
package.json
README.md
setup.sh
specs.md
verify_create_customer.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".adminjs/entry.js">
AdminJS.UserComponents = {}
</file>

<file path="src/admin/index.js">
/**
 * AdminJS Setup Module
 * 
 * Ops console approach: custom resources backed by services,
 * no DB adapter, global action guards, ADMIN-only auth.
 */

import AdminJS from 'adminjs';
import AdminJSExpress from '@adminjs/express';
import session from 'express-session';
import jwt from 'jsonwebtoken';
import { config } from '../config/index.js';
import { createChildLogger } from '../utils/logger.js';
import { getDatabase } from '../db/init.js';
import { createBackup, listBackups } from '../services/backupService.js';
import { getRecentLogs } from '../services/logService.js';
import * as customerService from '../services/customerService.js';
import * as vendorService from '../services/vendorService.js';
import * as productService from '../services/productService.js';
import * as invoiceService from '../services/invoiceService.js';
import * as paymentService from '../services/paymentService.js';
import * as settingsService from '../services/settingsService.js';
import { listUsers } from '../services/userService.js';

const adminLogger = createChildLogger('admin');

/**
 * Global action guard - disable all destructive actions
 */
const DISABLED_ACTIONS = ['new', 'edit', 'delete', 'bulkDelete'];

/**
 * Create a virtual resource for AdminJS (no DB adapter)
 * Returns data via service calls
 */
function createVirtualResource(name, options) {
    return {
        id: name,
        name: name,
        ...options,
        actions: {
            // Disable destructive actions globally
            new: { isAccessible: false },
            edit: { isAccessible: false },
            delete: { isAccessible: false },
            bulkDelete: { isAccessible: false },
            ...options.actions
        }
    };
}

/**
 * Setup AdminJS with custom resources
 */
export async function setupAdminJS(app) {
    // Define resources backed by services
    const resources = [];

    // AdminJS configuration
    const adminJs = new AdminJS({
        rootPath: '/admin',
        loginPath: '/admin/login',
        logoutPath: '/admin/logout',
        branding: {
            companyName: 'Swipe Admin',
            softwareBrothers: false,
            logo: false
        },
        dashboard: {
            handler: async () => {
                // Dashboard data
                const db = getDatabase();
                const stats = {
                    users: db.prepare('SELECT COUNT(*) as count FROM users').get().count,
                    customers: db.prepare('SELECT COUNT(*) as count FROM customers WHERE deleted_at IS NULL').get().count,
                    vendors: db.prepare('SELECT COUNT(*) as count FROM vendors WHERE deleted_at IS NULL').get().count,
                    products: db.prepare('SELECT COUNT(*) as count FROM products WHERE deleted_at IS NULL').get().count,
                    invoices: db.prepare('SELECT COUNT(*) as count FROM invoices WHERE deleted_at IS NULL').get().count,
                    payments: db.prepare('SELECT COUNT(*) as count FROM payments').get().count
                };
                return { stats };
            },
            component: false // Use default dashboard
        },
        resources: resources,
        pages: {
            // System status page
            'System Status': {
                handler: async (request, response, context) => {
                    const healthResponse = await fetch(`http://localhost:${config.port}/health`);
                    const health = await healthResponse.json();
                    return { health };
                },
                component: false
            }
        }
    });

    // Custom authenticate function - validates OTP + ADMIN role
    const authenticate = async (email, password) => {
        // For AdminJS, we use phone as email field
        // In local dev, OTP is static '111111'
        const db = getDatabase();
        const user = db.prepare('SELECT * FROM users WHERE phone = ? AND deleted_at IS NULL').get(email);

        if (!user) {
            adminLogger.warn({ phone: email }, 'Admin login attempt - user not found');
            return null;
        }

        // Verify OTP (static for dev)
        if (password !== '111111') {
            adminLogger.warn({ phone: email }, 'Admin login attempt - invalid OTP');
            return null;
        }

        // Check ADMIN role
        if (user.role !== 'ADMIN') {
            adminLogger.warn({ phone: email, role: user.role }, 'Admin login attempt - insufficient permissions (only ADMIN allowed)');
            return null;
        }

        adminLogger.info({ userId: user.id, shopId: user.shop_id, phone: email }, 'Admin login successful');

        return {
            id: user.id,
            email: user.phone,
            role: user.role,
            shopId: user.shop_id
        };
    };

    // Create router with session auth
    const adminRouter = AdminJSExpress.buildAuthenticatedRouter(
        adminJs,
        {
            authenticate,
            cookieName: 'adminjs',
            cookiePassword: config.jwtSecret || 'session-secret-change-me'
        },
        null, // No custom router
        {
            resave: false,
            saveUninitialized: false,
            secret: config.jwtSecret || 'session-secret-change-me',
            cookie: {
                httpOnly: true,
                secure: config.nodeEnv === 'production'
            }
        }
    );

    // Add custom API routes for admin actions
    adminRouter.get('/api/health', (req, res) => {
        if (!req.session || !req.session.adminUser) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        adminLogger.info({ userId: req.session.adminUser.id, requestId: req.requestId }, 'Admin action: health check');

        res.json({
            status: 'ok',
            timestamp: new Date().toISOString(),
            environment: config.nodeEnv,
            database: 'connected'
        });
    });

    adminRouter.post('/api/backup', (req, res) => {
        if (!req.session || !req.session.adminUser) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        try {
            adminLogger.info({ userId: req.session.adminUser.id, requestId: req.requestId }, 'Admin action: trigger backup');
            const backup = createBackup();
            adminLogger.info({ userId: req.session.adminUser.id, backup }, 'Backup created successfully');
            res.json({ success: true, backup });
        } catch (error) {
            adminLogger.error({ error: error.message }, 'Backup failed');
            res.status(500).json({ error: 'Backup failed', message: error.message });
        }
    });

    adminRouter.get('/api/backups', (req, res) => {
        if (!req.session || !req.session.adminUser) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        adminLogger.info({ userId: req.session.adminUser.id }, 'Admin action: list backups');
        const backups = listBackups();
        res.json({ backups });
    });

    adminRouter.get('/api/logs', (req, res) => {
        if (!req.session || !req.session.adminUser) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        adminLogger.info({ userId: req.session.adminUser.id }, 'Admin action: view logs');
        const logs = getRecentLogs();
        res.json(logs);
    });

    // Data browser endpoints (read-only)
    adminRouter.get('/api/data/users', (req, res) => {
        if (!req.session || !req.session.adminUser) {
            return res.status(401).json({ error: 'Unauthorized' });
        }
        const users = listUsers();
        res.json({ data: users, total: users.length });
    });

    adminRouter.get('/api/data/customers', (req, res) => {
        if (!req.session || !req.session.adminUser) {
            return res.status(401).json({ error: 'Unauthorized' });
        }
        const customers = customerService.listCustomers();
        res.json({ data: customers, total: customers.length });
    });

    adminRouter.get('/api/data/vendors', (req, res) => {
        if (!req.session || !req.session.adminUser) {
            return res.status(401).json({ error: 'Unauthorized' });
        }
        const vendors = vendorService.listVendors();
        res.json({ data: vendors, total: vendors.length });
    });

    adminRouter.get('/api/data/products', (req, res) => {
        if (!req.session || !req.session.adminUser) {
            return res.status(401).json({ error: 'Unauthorized' });
        }
        const products = productService.listProducts();
        res.json({ data: products, total: products.length });
    });

    adminRouter.get('/api/data/invoices', (req, res) => {
        if (!req.session || !req.session.adminUser) {
            return res.status(401).json({ error: 'Unauthorized' });
        }
        const invoices = invoiceService.listInvoices();
        res.json({ data: invoices, total: invoices.length });
    });

    adminRouter.get('/api/data/payments', (req, res) => {
        if (!req.session || !req.session.adminUser) {
            return res.status(401).json({ error: 'Unauthorized' });
        }
        const payments = paymentService.listPayments();
        res.json({ data: payments, total: payments.length });
    });

    adminRouter.get('/api/data/settings', (req, res) => {
        if (!req.session || !req.session.adminUser) {
            return res.status(401).json({ error: 'Unauthorized' });
        }
        const settings = settingsService.getAllSettings();
        res.json({ data: settings });
    });

    // Mount admin router
    app.use(adminJs.options.rootPath, adminRouter);

    adminLogger.info({ rootPath: adminJs.options.rootPath }, 'AdminJS mounted successfully');

    return adminJs;
}
</file>

<file path="src/config/swagger.js">
import swaggerJsdoc from 'swagger-jsdoc';

const options = {
    definition: {
        openapi: '3.0.0',
        info: {
            title: 'Swipe Backend API',
            version: '1.0.0',
        },
        servers: [
            {
                url: 'http://localhost:3000',
                description: 'Local Development Server',
            },
        ],
        components: {
            securitySchemes: {
                bearerAuth: {
                    type: 'http',
                    scheme: 'bearer',
                    bearerFormat: 'JWT',
                },
            },
            schemas: {
                InvoiceAggregate: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', format: 'uuid' },
                        invoiceNumber: { type: 'string' },
                        type: { type: 'string', enum: ['INVOICE', 'PROFORMA', 'LENDING'] },
                        status: { type: 'string', enum: ['PAID', 'PARTIAL', 'UNPAID', 'PENDING'] },
                        date: { type: 'string', format: 'date' },
                        dueDate: { type: 'string', format: 'date', nullable: true },
                        placeOfSupply: { type: 'string', nullable: true },
                        customer: {
                            type: 'object',
                            nullable: true,
                            properties: {
                                id: { type: 'string', format: 'uuid' },
                                name: { type: 'string' },
                                phone: { type: 'string', nullable: true },
                                gstin: { type: 'string', nullable: true },
                                address: { type: 'object', nullable: true },
                            },
                        },
                        items: {
                            type: 'array',
                            items: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string', format: 'uuid' },
                                    productId: { type: 'string', format: 'uuid', nullable: true },
                                    description: { type: 'string', nullable: true },
                                    quantity: { type: 'number' },
                                    rate: { type: 'number' },
                                    taxRate: { type: 'number', nullable: true },
                                    weight: { type: 'object', nullable: true },
                                    amount: { type: 'object', nullable: true },
                                },
                            },
                        },
                        totals: {
                            type: 'object',
                            nullable: true,
                            properties: {
                                subtotal: { type: 'number' },
                                taxTotal: { type: 'number' },
                                cgst: { type: 'number' },
                                sgst: { type: 'number' },
                                igst: { type: 'number' },
                                roundOff: { type: 'number' },
                                grandTotal: { type: 'number' },
                            },
                        },
                        photos: {
                            type: 'array',
                            items: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string', format: 'uuid' },
                                    url: { type: 'string' },
                                    createdAt: { type: 'string', format: 'date-time' },
                                },
                            },
                        },
                        createdAt: { type: 'string', format: 'date-time' },
                        updatedAt: { type: 'string', format: 'date-time' },
                    },
                },
                Customer: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', format: 'uuid' },
                        name: { type: 'string' },
                        phone: { type: 'string', nullable: true },
                        gstin: { type: 'string', nullable: true },
                        email: { type: 'string', nullable: true },
                        address: {
                            oneOf: [
                                { type: 'object' },
                                { type: 'string' }
                            ],
                            nullable: true
                        },
                        createdAt: { type: 'string', format: 'date-time' },
                        updatedAt: { type: 'string', format: 'date-time' },
                    },
                },
                Vendor: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', format: 'uuid' },
                        name: { type: 'string' },
                        phone: { type: 'string', nullable: true },
                        gstin: { type: 'string', nullable: true },
                        email: { type: 'string', nullable: true },
                        address: {
                            oneOf: [
                                { type: 'object' },
                                { type: 'string' }
                            ],
                            nullable: true
                        },
                        createdAt: { type: 'string', format: 'date-time' },
                        updatedAt: { type: 'string', format: 'date-time' },
                    },
                },
                Category: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', format: 'uuid' },
                        name: { type: 'string' },
                        type: { type: 'string', enum: ['product', 'service'] },
                        subcategories: {
                            type: 'array',
                            items: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string', format: 'uuid' },
                                    name: { type: 'string' },
                                    categoryId: { type: 'string', format: 'uuid' }
                                }
                            }
                        }
                    }
                },
                Product: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', format: 'uuid' },
                        type: { type: 'string', enum: ['product', 'service'] },
                        name: { type: 'string' },
                        sku: { type: 'string', nullable: true },
                        barcode: { type: 'string', nullable: true },
                        hsn: { type: 'string', nullable: true },
                        categoryId: { type: 'string', format: 'uuid', nullable: true },
                        subcategoryId: { type: 'string', format: 'uuid', nullable: true },
                        description: { type: 'string', nullable: true },
                        sellingPrice: { type: 'number' },
                        purchasePrice: { type: 'number' },
                        taxRate: { type: 'number' },
                        unit: { type: 'string', nullable: true },
                        metal: { type: 'object', nullable: true },
                        gemstone: { type: 'object', nullable: true },
                        design: { type: 'object', nullable: true },
                        images: {
                            type: 'array',
                            items: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string', format: 'uuid' },
                                    url: { type: 'string' },
                                    createdAt: { type: 'string', format: 'date-time' }
                                }
                            }
                        },
                        createdAt: { type: 'string', format: 'date-time' },
                        updatedAt: { type: 'string', format: 'date-time' }
                    }
                },
                Purchase: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', format: 'uuid' },
                        purchaseNumber: { type: 'string' },
                        vendorId: { type: 'string', format: 'uuid' },
                        status: { type: 'string', enum: ['RECEIVED', 'PENDING', 'ORDERED'] },
                        date: { type: 'string', format: 'date' },
                        dueDate: { type: 'string', format: 'date', nullable: true },
                        vendorInvoiceNumber: { type: 'string', nullable: true },
                        vendor: { $ref: '#/components/schemas/Vendor' },
                        items: {
                            type: 'array',
                            items: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string', format: 'uuid' },
                                    description: { type: 'string' },
                                    quantity: { type: 'number' },
                                    rate: { type: 'number' },
                                    taxRate: { type: 'number' },
                                    amount: { type: 'number' }
                                }
                            }
                        },
                        totals: {
                            type: 'object',
                            properties: {
                                subtotal: { type: 'number' },
                                taxTotal: { type: 'number' },
                                grandTotal: { type: 'number' }
                            }
                        }
                    }
                },
                Payment: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', format: 'uuid' },
                        receiptNumber: { type: 'string' },
                        type: { type: 'string', enum: ['IN', 'OUT'] },
                        partyType: { type: 'string', enum: ['CUSTOMER', 'VENDOR'] },
                        partyId: { type: 'string', format: 'uuid' },
                        amount: { type: 'number' },
                        date: { type: 'string', format: 'date' },
                        mode: { type: 'string' },
                        notes: { type: 'string', nullable: true },
                        allocations: {
                            type: 'array',
                            items: {
                                type: 'object',
                                properties: {
                                    invoiceId: { type: 'string', format: 'uuid' },
                                    amount: { type: 'number' }
                                }
                            }
                        },
                        createdAt: { type: 'string', format: 'date-time' }
                    }
                },
                Attendance: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', format: 'uuid' },
                        userId: { type: 'string', format: 'uuid' },
                        loginTime: { type: 'string', format: 'date-time' },
                        logoutTime: { type: 'string', format: 'date-time', nullable: true },
                        duration: { type: 'number', nullable: true },
                        date: { type: 'string', format: 'date' }
                    }
                },
                Setting: {
                    type: 'object',
                    properties: {
                        key: { type: 'string' },
                        value: {
                            oneOf: [
                                { type: 'string' },
                                { type: 'number' },
                                { type: 'boolean' },
                                { type: 'object' }
                            ]
                        }
                    }
                }
            },
        },
        security: [
            {
                bearerAuth: [],
            },
        ],
    },
    apis: ['./src/routes/*.js'], // Path to the API docs
};

export const swaggerSpec = swaggerJsdoc(options);
</file>

<file path="src/db/migrate_paisa.sql">
-- Add paisa columns to existing tables for integer-based financial calculations
-- This migration preserves existing data by immediately populating the new columns

-- 1. Add paisa columns to invoice_totals
ALTER TABLE invoice_totals ADD COLUMN subtotal_paisa INTEGER;
ALTER TABLE invoice_totals ADD COLUMN tax_total_paisa INTEGER;
ALTER TABLE invoice_totals ADD COLUMN cgst_paisa INTEGER;
ALTER TABLE invoice_totals ADD COLUMN sgst_paisa INTEGER;
ALTER TABLE invoice_totals ADD COLUMN igst_paisa INTEGER;
ALTER TABLE invoice_totals ADD COLUMN round_off_paisa INTEGER;
ALTER TABLE invoice_totals ADD COLUMN grand_total_paisa INTEGER;

-- Populate paisa columns from existing decimal values
UPDATE invoice_totals SET 
  subtotal_paisa = CAST(subtotal * 100 AS INTEGER),
  tax_total_paisa = CAST(tax_total * 100 AS INTEGER),
  cgst_paisa = CAST(COALESCE(cgst, 0) * 100 AS INTEGER),
  sgst_paisa = CAST(COALESCE(sgst, 0) * 100 AS INTEGER),
  igst_paisa = CAST(COALESCE(igst, 0) * 100 AS INTEGER),
  round_off_paisa = CAST(COALESCE(round_off, 0) * 100 AS INTEGER),
  grand_total_paisa = CAST(grand_total * 100 AS INTEGER);

-- 2. Add paisa column to customers
ALTER TABLE customers ADD COLUMN balance_paisa INTEGER;

UPDATE customers SET balance_paisa = CAST(balance * 100 AS INTEGER);

-- 3. Add paisa column to vendors
ALTER TABLE vendors ADD COLUMN balance_paisa INTEGER;

UPDATE vendors SET balance_paisa = CAST(balance * 100 AS INTEGER);

-- 4. Add paisa column to payments
ALTER TABLE payments ADD COLUMN amount_paisa INTEGER;

UPDATE payments SET amount_paisa = CAST(amount * 100 AS INTEGER);
</file>

<file path="src/middleware/errorHandler.js">
import crypto from 'crypto';

/**
 * Global error handler middleware
 * Must be registered last in the middleware chain
 */
export function errorHandler(err, req, res, next) {
    console.error('Error:', err);

    // Joi validation errors
    if (err.isJoi) {
        return res.status(400).json({
            error: 'Validation failed',
            details: err.details.map(d => ({
                field: d.path.join('.'),
                message: d.message
            })),
            requestId: req.requestId
        });
    }

    // SQLite constraint errors
    if (err.code && err.code.startsWith('SQLITE_')) {
        return res.status(400).json({
            error: 'Database constraint violation',
            details: err.message,
            requestId: req.requestId
        });
    }

    // Default error
    const statusCode = err.statusCode || 500;
    const message = err.message || 'Internal server error';

    res.status(statusCode).json({
        error: message,
        requestId: req.requestId,
        ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    });
}

/**
 * 404 Not Found handler
 */
export function notFoundHandler(req, res) {
    res.status(404).json({
        error: 'Endpoint not found',
        requestId: req.requestId
    });
}

/**
 * Request ID middleware
 * Generates a unique ID for each request for tracing
 */
export function requestIdMiddleware(req, res, next) {
    req.requestId = crypto.randomUUID();
    next();
}
</file>

<file path="src/middleware/shopScope.js">
/**
 * Shop Scope Middleware
 * Extracts shopId from authenticated JWT and injects into request context
 * 
 * CRITICAL: This middleware must run AFTER authenticateToken
 * Order: authenticateToken → injectShopScope → role middleware → handler
 */

/**
 * Inject shop scope from JWT into request
 * If shopId is missing after authentication, returns 500 (never falls back to default)
 */
export function injectShopScope(req, res, next) {
    // Only inject if user is authenticated
    if (req.user) {
        if (!req.user.shopId) {
            // SECURITY: Never fall back to a default shop
            return res.status(500).json({
                error: 'Internal error: Shop context missing from token',
                requestId: req.requestId
            });
        }
        req.shopId = req.user.shopId;
    }
    next();
}

/**
 * Require shop scope for protected routes
 * Use this as a safety check on routes that absolutely require shop context
 */
export function requireShopScope(req, res, next) {
    if (!req.shopId) {
        return res.status(500).json({
            error: 'Internal error: Shop scope required but missing',
            requestId: req.requestId
        });
    }
    next();
}
</file>

<file path="src/middleware/validator.js">
import Joi from 'joi';

/**
 * Validation middleware factory
 * @param {Joi.Schema} schema - Joi validation schema
 * @param {String} source - Request property to validate ('body', 'query', 'params')
 */
export function validate(schema, source = 'body') {
    return (req, res, next) => {
        const { error, value } = schema.validate(req[source], {
            abortEarly: false,
            stripUnknown: true
        });

        if (error) {
            error.isJoi = true;
            return next(error);
        }

        // Replace request data with validated data
        req[source] = value;
        next();
    };
}

// Common validation schemas
export const schemas = {
    uuid: Joi.string().uuid(),

    customer: Joi.object({
        name: Joi.string().required(),
        gstin: Joi.string().allow(null, ''),
        phone: Joi.string().allow(null, ''),
        email: Joi.string().email().allow(null, ''),
        address: Joi.alternatives().try(Joi.object(), Joi.string()).allow(null, '')
    }),

    vendor: Joi.object({
        name: Joi.string().required(),
        gstin: Joi.string().allow(null, ''),
        phone: Joi.string().allow(null, ''),
        email: Joi.string().email().allow(null, ''),
        address: Joi.alternatives().try(Joi.object(), Joi.string()).allow(null, '')
    }),

    product: Joi.object({
        type: Joi.string().valid('product', 'service').required(),
        name: Joi.string().required(),
        sku: Joi.string().allow(null, ''),
        barcode: Joi.string().allow(null, ''),
        hsn: Joi.string().allow(null, ''),
        categoryId: Joi.string().uuid().allow(null),
        subcategoryId: Joi.string().uuid().allow(null),
        description: Joi.string().allow(null, ''),
        sellingPrice: Joi.number().min(0).allow(null),
        purchasePrice: Joi.number().min(0).allow(null),
        taxRate: Joi.number().min(0).max(100).allow(null),
        unit: Joi.string().allow(null, ''),
        metal: Joi.object().allow(null),
        gemstone: Joi.object().allow(null),
        design: Joi.object().allow(null),
        vendorRef: Joi.string().allow(null, ''),
        procurementDate: Joi.string().isoDate().allow(null),
        hallmarkCert: Joi.string().allow(null, ''),
        launchDate: Joi.string().isoDate().allow(null),
        showOnline: Joi.boolean().default(false),
        notForSale: Joi.boolean().default(false)
    }),

    invoiceItem: Joi.object({
        productId: Joi.string().uuid().allow(null),
        description: Joi.string().allow(null, ''),
        quantity: Joi.number().required(),
        rate: Joi.number().required(),
        taxRate: Joi.number().min(0).max(100).allow(null),
        weight: Joi.object().allow(null),
        amount: Joi.object().allow(null)
    }),

    invoice: Joi.object({
        customerId: Joi.string().uuid().allow(null),
        type: Joi.string().valid('INVOICE', 'PROFORMA', 'LENDING').required(),
        status: Joi.string().valid('PAID', 'PARTIAL', 'UNPAID', 'PENDING').default('UNPAID'),
        date: Joi.string().isoDate().required(),
        dueDate: Joi.string().isoDate().allow(null),
        placeOfSupply: Joi.string().allow(null, ''),
        customer: Joi.object({
            name: Joi.string().required(),
            phone: Joi.string().allow(null, ''),
            gstin: Joi.string().allow(null, ''),
            address: Joi.alternatives().try(Joi.object(), Joi.string()).allow(null, '')
        }).required(),
        items: Joi.array().items(Joi.link('#invoiceItem')).min(1).required()
    }).id('invoice').shared(Joi.object().id('invoiceItem')),

    payment: Joi.object({
        type: Joi.string().valid('IN', 'OUT').required(),
        partyType: Joi.string().valid('CUSTOMER', 'VENDOR').required(),
        partyId: Joi.string().uuid().required(),
        amount: Joi.number().min(0).required(),
        date: Joi.string().isoDate().required(),
        mode: Joi.string().allow(null, ''),
        notes: Joi.string().allow(null, ''),
        allocations: Joi.array().items(
            Joi.object({
                invoiceId: Joi.string().uuid().required(),
                amount: Joi.number().min(0).required()
            })
        ).default([])
    })
};
</file>

<file path="src/routes/attendance.js">
import express from 'express';
import {
    logLogin,
    logLogout,
    getAttendanceByDate,
    getAttendanceHistory,
    getAllAttendanceByDate
} from '../services/attendanceService.js';

const router = express.Router();

/**
 * @swagger
 * /api/attendance/login:
 *   post:
 *     summary: Record user login
 *     tags: [Attendance]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [userId]
 *             properties:
 *               userId:
 *                 type: string
 *                 format: uuid
 *     responses:
 *       201:
 *         description: Login recorded
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Attendance'
 */
router.post('/login', (req, res, next) => {
    try {
        const { userId } = req.body;
        if (!userId) {
            return res.status(400).json({ error: 'userId is required', requestId: req.requestId });
        }
        const log = logLogin(userId);
        res.status(201).json(log);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/attendance/logout:
 *   post:
 *     summary: Record user logout
 *     tags: [Attendance]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [logId]
 *             properties:
 *               logId:
 *                 type: string
 *                 format: uuid
 *     responses:
 *       200:
 *         description: Logout recorded
 */
router.post('/logout', (req, res, next) => {
    try {
        const { logId } = req.body;
        if (!logId) {
            return res.status(400).json({ error: 'logId is required', requestId: req.requestId });
        }
        const result = logLogout(logId);
        res.json(result);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/attendance/user/{userId}:
 *   get:
 *     summary: Get attendance history for a user
 *     tags: [Attendance]
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 30
 *     responses:
 *       200:
 *         description: Attendance history
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Attendance'
 */
router.get('/user/:userId', (req, res, next) => {
    try {
        const limit = parseInt(req.query.limit) || 30;
        const history = getAttendanceHistory(req.params.userId, limit);
        res.json(history);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/attendance/user/{userId}/date/{date}:
 *   get:
 *     summary: Get attendance for a user on a specific date
 *     tags: [Attendance]
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *       - in: path
 *         name: date
 *         required: true
 *         schema:
 *           type: string
 *           format: date
 *     responses:
 *       200:
 *         description: Attendance logs
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Attendance'
 */
router.get('/user/:userId/date/:date', (req, res, next) => {
    try {
        const logs = getAttendanceByDate(req.params.userId, req.params.date);
        res.json(logs);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/attendance/date/{date}:
 *   get:
 *     summary: Get all attendance for a date (admin)
 *     tags: [Attendance]
 *     parameters:
 *       - in: path
 *         name: date
 *         required: true
 *         schema:
 *           type: string
 *           format: date
 *     responses:
 *       200:
 *         description: Attendance logs
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Attendance'
 */
router.get('/date/:date', (req, res, next) => {
    try {
        const logs = getAllAttendanceByDate(req.params.date);
        res.json(logs);
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="src/routes/home.js">
import express from 'express';
import { authenticateToken } from '../middleware/auth.js';
import { injectShopScope } from '../middleware/shopScope.js';
import { generateHomeSnapshot } from '../services/home/homeSnapshot.service.js';

const router = express.Router();

// In-memory cache with TTL (5 minutes)
const cache = new Map();
const CACHE_TTL_MS = 5 * 60 * 1000;

// All routes require authentication and shop scope
router.use(authenticateToken);
router.use(injectShopScope);

/**
 * @swagger
 * /api/home/snapshot:
 *   get:
 *     summary: Get aggregated home screen data
 *     description: Returns business metrics, risk summary, activity cards, and momentum
 *     tags: [Home]
 */
router.get('/snapshot', (req, res, next) => {
    try {
        const cacheKey = `snapshot:${req.shopId}`;
        const cached = cache.get(cacheKey);

        // Check cache validity
        if (cached && (Date.now() - cached.timestamp < CACHE_TTL_MS)) {
            return res.json(cached.data);
        }

        // Generate fresh snapshot
        const snapshot = generateHomeSnapshot(req.shopId);

        // Cache result
        cache.set(cacheKey, {
            data: snapshot,
            timestamp: Date.now()
        });

        res.json(snapshot);
    } catch (error) {
        next(error);
    }
});

/**
 * Bust cache for a shop (internal use by other services)
 * @param {string} shopId - Shop UUID
 */
export function bustHomeCache(shopId) {
    const cacheKey = `snapshot:${shopId}`;
    const deleted = cache.delete(cacheKey);

    if (deleted) {
        console.log(`[Cache] Busted home snapshot cache for shop: ${shopId}`);
    }
}

export default router;
</file>

<file path="src/routes/setup.js">
// SECURITY: Bootstrap endpoint for initial shop creation
// This endpoint should only be used once during initial setup

import express from 'express';
import { getDatabase, transaction } from '../db/init.js';
import { generateUUID } from '../utils/uuid.js';
import { config } from '../config/index.js';
import { createChildLogger } from '../utils/logger.js';

const setupLogger = createChildLogger('setup');
const router = express.Router();

/**
 * POST /api/setup/bootstrap
 * Create the first shop and admin user
 * 
 * Requires: setupSecret matching SETUP_SECRET env var
 * Can only run once (if shop exists, requires valid secret to proceed)
 */
router.post('/bootstrap', (req, res, next) => {
    try {
        const { shopName, adminPhone, setupSecret } = req.body;

        // Validate required fields
        if (!shopName || !adminPhone || !setupSecret) {
            return res.status(400).json({
                error: 'Missing required fields: shopName, adminPhone, setupSecret',
                requestId: req.requestId
            });
        }

        const db = getDatabase();

        // Check if any shop already exists
        const existingShop = db.prepare('SELECT id FROM shops LIMIT 1').get();

        if (existingShop) {
            // Shop exists - validate secret for re-bootstrap
            if (setupSecret !== config.setupSecret) {
                return res.status(403).json({
                    error: 'Shop already exists. Invalid setup secret.',
                    requestId: req.requestId
                });
            }
            // With valid secret, allow re-bootstrap (for dev/testing)
            setupLogger.warn('Re-bootstrap attempted with valid secret');
        }

        // Validate setup secret
        if (setupSecret !== config.setupSecret) {
            return res.status(403).json({
                error: 'Invalid setup secret',
                requestId: req.requestId
            });
        }

        // Check if phone already registered
        const existingUser = db.prepare('SELECT id FROM users WHERE phone = ?').get(adminPhone);
        if (existingUser) {
            return res.status(409).json({
                error: 'Phone number already registered',
                requestId: req.requestId
            });
        }

        // Transactional shop + user creation
        const result = transaction((db) => {
            const shopId = generateUUID();
            const userId = generateUUID();
            const now = new Date().toISOString();

            // Create shop
            db.prepare(`
                INSERT INTO shops (id, name, created_at)
                VALUES (?, ?, ?)
            `).run(shopId, shopName, now);

            // Initialize sequences for the new shop
            const sequences = [
                { key: 'invoice_seq', value: 1 },
                { key: 'purchase_seq', value: 1 },
                { key: 'payment_seq', value: 1 }
            ];
            const insertSeq = db.prepare(`
                INSERT OR IGNORE INTO sequences (shop_id, key, value) VALUES (?, ?, ?)
            `);
            sequences.forEach(seq => {
                insertSeq.run(shopId, seq.key, seq.value);
            });

            // Create admin user
            db.prepare(`
                INSERT INTO users (id, shop_id, phone, name, role, created_at)
                VALUES (?, ?, ?, ?, ?, ?)
            `).run(userId, shopId, adminPhone, 'Admin', 'ADMIN', now);

            setupLogger.info({ shopId, userId, shopName, adminPhone }, 'Shop bootstrapped successfully');

            return {
                shop: { id: shopId, name: shopName },
                user: { id: userId, phone: adminPhone, role: 'ADMIN' }
            };
        });

        res.status(201).json({
            success: true,
            message: 'Shop bootstrapped successfully',
            ...result
        });

    } catch (error) {
        next(error);
    }
});

/**
 * GET /api/setup/status
 * Check if setup has been completed (any shop exists)
 */
router.get('/status', (req, res, next) => {
    try {
        const db = getDatabase();
        const shop = db.prepare('SELECT id, name FROM shops LIMIT 1').get();

        res.json({
            setupComplete: !!shop,
            shop: shop ? { id: shop.id, name: shop.name } : null
        });
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="src/services/home/businessPulse.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase } from '../../db/init.js';

/**
 * Calculate business pulse metrics
 * @param {string} shopId - Shop UUID
 * @returns {import('./homeSnapshot.types.js').BusinessPulse}
 */
export function calculateBusinessPulse(shopId) {
    const db = getDatabase();

    // Calculate week boundaries (Monday to Sunday)
    const now = new Date();
    const currentDayOfWeek = now.getDay(); // 0 = Sunday, 1 = Monday, ...
    const daysToMonday = currentDayOfWeek === 0 ? 6 : currentDayOfWeek - 1;

    const startOfThisWeek = new Date(now);
    startOfThisWeek.setDate(now.getDate() - daysToMonday);
    startOfThisWeek.setHours(0, 0, 0, 0);

    const startOfLastWeek = new Date(startOfThisWeek);
    startOfLastWeek.setDate(startOfThisWeek.getDate() - 7);

    const startOfNextWeek = new Date(startOfThisWeek);
    startOfNextWeek.setDate(startOfThisWeek.getDate() + 7);

    // Format dates for SQLite (YYYY-MM-DD)
    const formatDate = (date) => date.toISOString().split('T')[0];

    // Current week: payments IN (received)
    const currentWeek = db.prepare(`
        SELECT 
            COUNT(*) as count,
            COALESCE(SUM(amount), 0) as total
        FROM payments
        WHERE shop_id = ? 
        AND type = 'IN'
        AND date >= ?
        AND date < ?
    `).get(shopId, formatDate(startOfThisWeek), formatDate(startOfNextWeek));

    // Last week for comparison
    const lastWeek = db.prepare(`
        SELECT 
            COALESCE(SUM(amount), 0) as total
        FROM payments
        WHERE shop_id = ? 
        AND type = 'IN'
        AND date >= ?
        AND date < ?
    `).get(shopId, formatDate(startOfLastWeek), formatDate(startOfThisWeek));

    // Calculate percentage change (avoid division by zero)
    const percentChange = lastWeek.total > 0
        ? ((currentWeek.total - lastWeek.total) / lastWeek.total) * 100
        : (currentWeek.total > 0 ? 100 : 0);

    return {
        amountReceivedThisWeek: currentWeek.total,
        percentChangeWoW: Math.round(percentChange * 10) / 10, // 1 decimal place
        paymentsCompleted: currentWeek.count
    };
}
</file>

<file path="src/services/home/homeSnapshot.service.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { calculateBusinessPulse } from './businessPulse.js';
import { calculateRiskSummary } from './riskSummary.js';
import { generateRecentActivity } from './recentActivity.js';
import { calculateMomentum } from './momentum.js';
import { calculatePrimaryAction } from './primaryAction.js';

/**
 * Generate complete home snapshot
 * @param {string} shopId - Shop UUID
 * @returns {import('./homeSnapshot.types.js').HomeSnapshot}
 */
export function generateHomeSnapshot(shopId) {
    return {
        snapshotVersion: 1,
        businessPulse: calculateBusinessPulse(shopId),
        primaryAction: calculatePrimaryAction(shopId),
        recentActivity: generateRecentActivity(shopId),
        riskSummary: calculateRiskSummary(shopId),
        momentum: calculateMomentum(shopId),
        generatedAt: new Date().toISOString()
    };
}
</file>

<file path="src/services/home/homeSnapshot.types.js">
// Type definitions for Home Snapshot API
// These JSDoc typedefs provide IDE autocomplete and documentation

/**
 * @typedef {Object} BusinessPulse
 * @property {number} amountReceivedThisWeek - Total amount received this week
 * @property {number} percentChangeWoW - Week over Week percentage change (1 decimal)
 * @property {number} paymentsCompleted - Number of payments completed this week
 */

/**
 * @typedef {Object} PrimaryAction
 * @property {"INVOICE"|"PURCHASE"|"EXPENSE"} mostUsed - Most frequently used action in last 30 days
 */

/**
 * @typedef {Object} ActivityCard
 * @property {"INVOICE"|"PAYMENT"|"RISK"} type - Card type
 * @property {string} title - Card title
 * @property {string} subtitle - Secondary text (e.g., customer name)
 * @property {number} amount - Monetary amount
 * @property {string} status - Status indicator (e.g., "OVERDUE", "PAID")
 * @property {string} date - ISO date string
 * @property {string} entityId - Invoice/Payment UUID for navigation
 */

/**
 * @typedef {Object} RiskSummary
 * @property {number} unpaidInvoicesCount - Count of unpaid/partial invoices
 * @property {number} unpaidAmount - Total unpaid amount
 */

/**
 * @typedef {Object} Momentum
 * @property {number} invoiceStreakDays - Consecutive days with at least one invoice
 * @property {number} totalSentThisWeek - Number of invoices sent this week
 */

/**
 * @typedef {Object} HomeSnapshot
 * @property {number} snapshotVersion - Snapshot schema version (currently 1)
 * @property {BusinessPulse} businessPulse - Weekly payment metrics
 * @property {PrimaryAction} primaryAction - Most used action
 * @property {ActivityCard[]} recentActivity - Curated activity cards (max 3)
 * @property {RiskSummary} riskSummary - Unpaid invoice summary
 * @property {Momentum} momentum - Invoice creation streak
 * @property {string} generatedAt - ISO timestamp when snapshot was generated
 */

// Export empty object (this file is for types only)
export { };
</file>

<file path="src/services/home/momentum.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase } from '../../db/init.js';

/**
 * Calculate momentum metrics (invoice streak)
 * @param {string} shopId - Shop UUID
 * @returns {import('./homeSnapshot.types.js').Momentum}
 */
export function calculateMomentum(shopId) {
    const db = getDatabase();

    // Get all invoice creation dates (distinct days)
    const dates = db.prepare(`
        SELECT DISTINCT DATE(created_at) as date
        FROM invoices
        WHERE shop_id = ?
        AND deleted_at IS NULL
        ORDER BY date DESC
    `).all(shopId);

    // Count consecutive days from today backwards
    let streak = 0;
    let currentDate = new Date();
    currentDate.setHours(0, 0, 0, 0);

    for (const row of dates) {
        const invoiceDate = new Date(row.date + 'T00:00:00');
        const diffDays = Math.floor((currentDate - invoiceDate) / (1000 * 60 * 60 * 24));

        if (diffDays === streak) {
            // Consecutive day
            streak++;
            currentDate = new Date(invoiceDate);
        } else if (diffDays > streak) {
            // Gap found, streak is broken
            break;
        }
    }

    // Total sent this week
    const now = new Date();
    const currentDayOfWeek = now.getDay();
    const daysToMonday = currentDayOfWeek === 0 ? 6 : currentDayOfWeek - 1;

    const startOfThisWeek = new Date(now);
    startOfThisWeek.setDate(now.getDate() - daysToMonday);
    startOfThisWeek.setHours(0, 0, 0, 0);

    const formatDate = (date) => date.toISOString().split('T')[0];

    const thisWeek = db.prepare(`
        SELECT COUNT(*) as count
        FROM invoices
        WHERE shop_id = ?
        AND DATE(created_at) >= ?
        AND deleted_at IS NULL
    `).get(shopId, formatDate(startOfThisWeek));

    return {
        invoiceStreakDays: streak,
        totalSentThisWeek: thisWeek.count
    };
}
</file>

<file path="src/services/home/primaryAction.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase } from '../../db/init.js';

/**
 * Calculate primary action (most used in last 30 days)
 * @param {string} shopId - Shop UUID
 * @returns {import('./homeSnapshot.types.js').PrimaryAction}
 */
export function calculatePrimaryAction(shopId) {
    const db = getDatabase();

    // Calculate date 30 days ago
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const cutoffDate = thirtyDaysAgo.toISOString();

    // Count invoices
    const invoiceCount = db.prepare(`
        SELECT COUNT(*) as count 
        FROM invoices 
        WHERE shop_id = ? 
        AND created_at >= ?
        AND deleted_at IS NULL
    `).get(shopId, cutoffDate).count;

    // Count purchases
    const purchaseCount = db.prepare(`
        SELECT COUNT(*) as count 
        FROM purchases 
        WHERE shop_id = ? 
        AND created_at >= ?
        AND deleted_at IS NULL
    `).get(shopId, cutoffDate).count;

    // Count payments (used as proxy for expense tracking)
    const paymentCount = db.prepare(`
        SELECT COUNT(*) as count 
        FROM payments 
        WHERE shop_id = ? 
        AND created_at >= ?
        AND type = 'OUT'
    `).get(shopId, cutoffDate).count;

    // Determine most used action
    const max = Math.max(invoiceCount, purchaseCount, paymentCount);

    if (max === 0) {
        // Default to INVOICE if no activity
        return { mostUsed: 'INVOICE' };
    }

    if (invoiceCount === max) {
        return { mostUsed: 'INVOICE' };
    }

    if (purchaseCount === max) {
        return { mostUsed: 'PURCHASE' };
    }

    return { mostUsed: 'EXPENSE' };
}
</file>

<file path="src/services/home/recentActivity.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase } from '../../db/init.js';

/**
 * Generate curated activity cards (business logic, not raw data)
 * 
 * Rules:
 * 1. First card: oldest overdue invoice (if any)
 * 2. Second card: last paid invoice (if any)  
 * 3. Third card: risk summary OR recent creation
 * 
 * @param {string} shopId - Shop UUID
 * @returns {import('./homeSnapshot.types.js').ActivityCard[]}
 */
export function generateRecentActivity(shopId) {
    const db = getDatabase();
    const cards = [];
    const today = new Date().toISOString().split('T')[0];

    // Card 1: Oldest overdue invoice
    const overdue = db.prepare(`
        SELECT 
            i.id, 
            i.invoice_number, 
            i.due_date, 
            it.grand_total,
            ics.name as customer_name
        FROM invoices i
        JOIN invoice_totals it ON i.id = it.invoice_id
        LEFT JOIN invoice_customer_snapshot ics ON i.id = ics.invoice_id
        WHERE i.shop_id = ?
        AND i.status IN ('UNPAID', 'PARTIAL')
        AND i.due_date < ?
        AND i.deleted_at IS NULL
        ORDER BY i.due_date ASC
        LIMIT 1
    `).get(shopId, today);

    if (overdue) {
        cards.push({
            type: 'INVOICE',
            title: `Overdue: ${overdue.invoice_number}`,
            subtitle: overdue.customer_name || 'Unknown Customer',
            amount: overdue.grand_total,
            status: 'OVERDUE',
            date: overdue.due_date,
            entityId: overdue.id
        });
    }

    // Card 2: Last paid invoice
    const lastPaid = db.prepare(`
        SELECT 
            i.id, 
            i.invoice_number, 
            i.date,
            it.grand_total,
            ics.name as customer_name
        FROM invoices i
        JOIN invoice_totals it ON i.id = it.invoice_id
        LEFT JOIN invoice_customer_snapshot ics ON i.id = ics.invoice_id
        WHERE i.shop_id = ?
        AND i.status = 'PAID'
        AND i.deleted_at IS NULL
        ORDER BY i.updated_at DESC
        LIMIT 1
    `).get(shopId);

    if (lastPaid) {
        cards.push({
            type: 'INVOICE',
            title: `Paid: ${lastPaid.invoice_number}`,
            subtitle: lastPaid.customer_name || 'Unknown Customer',
            amount: lastPaid.grand_total,
            status: 'PAID',
            date: lastPaid.date,
            entityId: lastPaid.id
        });
    }

    // Card 3: Risk summary if unpaid invoices exist, otherwise recent creation
    const unpaidCount = db.prepare(`
        SELECT COUNT(*) as count
        FROM invoices
        WHERE shop_id = ?
        AND status IN ('UNPAID', 'PARTIAL')
        AND deleted_at IS NULL
    `).get(shopId).count;

    if (unpaidCount > 0 && cards.length < 3) {
        const unpaidTotal = db.prepare(`
            SELECT COALESCE(SUM(it.grand_total), 0) as total
            FROM invoices i
            JOIN invoice_totals it ON i.id = it.invoice_id
            WHERE i.shop_id = ?
            AND i.status IN ('UNPAID', 'PARTIAL')
            AND i.deleted_at IS NULL
        `).get(shopId).total;

        cards.push({
            type: 'RISK',
            title: `${unpaidCount} Unpaid Invoice${unpaidCount > 1 ? 's' : ''}`,
            subtitle: 'Action required',
            amount: unpaidTotal,
            status: 'UNPAID',
            date: today,
            entityId: '' // No specific entity
        });
    } else if (cards.length < 3) {
        // Show most recent invoice creation
        const recent = db.prepare(`
            SELECT 
                i.id, 
                i.invoice_number, 
                i.date,
                it.grand_total,
                ics.name as customer_name
            FROM invoices i
            JOIN invoice_totals it ON i.id = it.invoice_id
            LEFT JOIN invoice_customer_snapshot ics ON i.id = ics.invoice_id
            WHERE i.shop_id = ?
            AND i.deleted_at IS NULL
            ORDER BY i.created_at DESC
            LIMIT 1
        `).get(shopId);

        if (recent) {
            cards.push({
                type: 'INVOICE',
                title: `Recent: ${recent.invoice_number}`,
                subtitle: recent.customer_name || 'Unknown Customer',
                amount: recent.grand_total,
                status: 'CREATED',
                date: recent.date,
                entityId: recent.id
            });
        }
    }

    return cards;
}
</file>

<file path="src/services/home/riskSummary.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase } from '../../db/init.js';

/**
 * Calculate risk summary (unpaid invoices)
 * @param {string} shopId - Shop UUID
 * @returns {import('./homeSnapshot.types.js').RiskSummary}
 */
export function calculateRiskSummary(shopId) {
    const db = getDatabase();

    const result = db.prepare(`
        SELECT 
            COUNT(*) as count,
            COALESCE(SUM(it.grand_total - COALESCE(paid.total, 0)), 0) as unpaid
        FROM invoices i
        JOIN invoice_totals it ON i.id = it.invoice_id
        LEFT JOIN (
            SELECT invoice_id, SUM(amount) as total
            FROM payment_allocations
            GROUP BY invoice_id
        ) paid ON i.id = paid.invoice_id
        WHERE i.shop_id = ?
        AND i.status IN ('UNPAID', 'PARTIAL')
        AND i.deleted_at IS NULL
    `).get(shopId);

    return {
        unpaidInvoicesCount: result.count,
        unpaidAmount: result.unpaid
    };
}
</file>

<file path="src/services/attendanceService.js">
import { getDatabase } from '../db/init.js';
import { generateUUID } from '../utils/uuid.js';

/**
 * Log user login (start attendance)
 */
export function logLogin(userId) {
    const db = getDatabase();
    const logId = generateUUID();
    const now = new Date();
    const loginDate = now.toISOString().split('T')[0];
    const loginAt = now.toISOString();

    db.prepare(`
    INSERT INTO attendance_logs (id, user_id, login_date, login_at, created_at)
    VALUES (?, ?, ?, ?, ?)
  `).run(logId, userId, loginDate, loginAt, loginAt);

    return { id: logId, userId, loginDate, loginAt };
}

/**
 * Log user logout (end attendance)
 */
export function logLogout(logId) {
    const db = getDatabase();
    const logoutAt = new Date().toISOString();

    const result = db.prepare(
        'UPDATE attendance_logs SET logout_at = ? WHERE id = ? AND logout_at IS NULL'
    ).run(logoutAt, logId);

    if (result.changes === 0) throw new Error('Attendance log not found or already logged out');
    return { logId, logoutAt };
}

/**
 * Get attendance for a user on a specific date
 */
export function getAttendanceByDate(userId, date) {
    const db = getDatabase();
    return db.prepare(
        'SELECT * FROM attendance_logs WHERE user_id = ? AND login_date = ? ORDER BY login_at'
    ).all(userId, date);
}

/**
 * Get attendance history for a user
 */
export function getAttendanceHistory(userId, limit = 30) {
    const db = getDatabase();
    return db.prepare(
        'SELECT * FROM attendance_logs WHERE user_id = ? ORDER BY login_date DESC, login_at DESC LIMIT ?'
    ).all(userId, limit);
}

/**
 * Get all attendance for a date (admin view)
 */
export function getAllAttendanceByDate(date) {
    const db = getDatabase();
    return db.prepare(`
    SELECT al.*, u.username FROM attendance_logs al
    LEFT JOIN users u ON al.user_id = u.id
    WHERE al.login_date = ? ORDER BY al.login_at
  `).all(date);
}
</file>

<file path="src/services/logService.js">
/**
 * Log Service
 * Read-only log viewing with hardened access
 */

import { readFileSync, existsSync, statSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Hardcoded log path - no user input accepted
const LOG_PATH = join(__dirname, '../../logs/app.log');
const MAX_LINES = 500;

/**
 * Read recent log entries (tail, max 500 lines)
 * @returns {Object} Log content and metadata
 */
export function getRecentLogs() {
    if (!existsSync(LOG_PATH)) {
        return {
            lines: [],
            message: 'Log file does not exist (logs are only created in production)',
            path: LOG_PATH
        };
    }

    const stats = statSync(LOG_PATH);
    const content = readFileSync(LOG_PATH, 'utf-8');
    const allLines = content.split('\n').filter(line => line.trim());

    // Take last MAX_LINES
    const lines = allLines.slice(-MAX_LINES);

    return {
        lines,
        totalLines: allLines.length,
        displayedLines: lines.length,
        maxLines: MAX_LINES,
        fileSizeBytes: stats.size,
        lastModified: stats.mtime.toISOString()
    };
}
</file>

<file path="src/services/shopService.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase } from '../db/init.js';
import { generateUUID } from '../utils/uuid.js';
import { createChildLogger } from '../utils/logger.js';

const shopLogger = createChildLogger('shop');

/**
 * Create a new shop
 * @param {string} name - Shop name
 * @returns {Object} Created shop
 */
export function createShop(name) {
    const db = getDatabase();
    const shopId = generateUUID();
    const now = new Date().toISOString();

    db.prepare(`
        INSERT INTO shops (id, name, created_at)
        VALUES (?, ?, ?)
    `).run(shopId, name, now);

    // Initialize sequences for the new shop
    initializeShopSequences(shopId);

    shopLogger.info({ shopId, name }, 'Shop created');

    return { id: shopId, name, created_at: now };
}

/**
 * Initialize default sequences for a shop
 * @param {string} shopId - Shop UUID
 */
export function initializeShopSequences(shopId) {
    const db = getDatabase();
    const sequences = [
        { key: 'invoice_seq', value: 1 },
        { key: 'purchase_seq', value: 1 },
        { key: 'payment_seq', value: 1 }
    ];

    const insertStmt = db.prepare(`
        INSERT OR IGNORE INTO sequences (shop_id, key, value) VALUES (?, ?, ?)
    `);

    sequences.forEach(seq => {
        insertStmt.run(shopId, seq.key, seq.value);
    });

    shopLogger.debug({ shopId }, 'Initialized shop sequences');
}

/**
 * Get a shop by ID
 * @param {string} shopId - Shop UUID
 * @returns {Object|null} Shop or null
 */
export function getShop(shopId) {
    const db = getDatabase();
    return db.prepare('SELECT * FROM shops WHERE id = ?').get(shopId) || null;
}

/**
 * Update shop details (ADMIN only)
 * @param {string} shopId - Shop UUID
 * @param {Object} data - Update data
 * @returns {Object} Updated shop
 */
export function updateShop(shopId, data) {
    const db = getDatabase();

    const result = db.prepare(`
        UPDATE shops SET name = ? WHERE id = ?
    `).run(data.name, shopId);

    if (result.changes === 0) {
        throw new Error('Shop not found');
    }

    shopLogger.info({ shopId }, 'Shop updated');

    return getShop(shopId);
}
</file>

<file path="src/utils/checksum.js">
import crypto from 'crypto';

/**
 * Calculate SHA-256 checksum of a file buffer
 * @param {Buffer} buffer - File buffer
 * @returns {string} Hexadecimal checksum
 */
export function calculateChecksum(buffer) {
    return crypto.createHash('sha256').update(buffer).digest('hex');
}
</file>

<file path="src/utils/logger.test.js">
/**
 * Logger Unit Tests
 * 
 * Tests for the centralized Pino logger module
 */

import { jest } from '@jest/globals';

// Mock pino before importing logger
jest.unstable_mockModule('pino', () => ({
    default: jest.fn(() => ({
        info: jest.fn(),
        warn: jest.fn(),
        error: jest.fn(),
        debug: jest.fn(),
        fatal: jest.fn(),
        child: jest.fn(() => ({
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn(),
            debug: jest.fn()
        }))
    })),
    stdTimeFunctions: {
        isoTime: jest.fn()
    }
}));

jest.unstable_mockModule('pino-http', () => ({
    default: jest.fn(() => (req, res, next) => next())
}));

// Import after mocks
const { logger, createChildLogger, createHttpLogger } = await import('./logger.js');

describe('Logger Module', () => {
    describe('logger instance', () => {
        test('logger exists and is defined', () => {
            expect(logger).toBeDefined();
        });

        test('logger has info method', () => {
            expect(typeof logger.info).toBe('function');
        });

        test('logger has warn method', () => {
            expect(typeof logger.warn).toBe('function');
        });

        test('logger has error method', () => {
            expect(typeof logger.error).toBe('function');
        });

        test('logger has debug method', () => {
            expect(typeof logger.debug).toBe('function');
        });

        test('logger has fatal method', () => {
            expect(typeof logger.fatal).toBe('function');
        });
    });

    describe('createChildLogger', () => {
        test('returns a logger instance', () => {
            const childLogger = createChildLogger('testModule');
            expect(childLogger).toBeDefined();
        });

        test('child logger has expected methods', () => {
            const childLogger = createChildLogger('testModule');
            expect(typeof childLogger.info).toBe('function');
            expect(typeof childLogger.warn).toBe('function');
            expect(typeof childLogger.error).toBe('function');
            expect(typeof childLogger.debug).toBe('function');
        });
    });

    describe('createHttpLogger', () => {
        test('returns a middleware function', () => {
            const middleware = createHttpLogger();
            expect(typeof middleware).toBe('function');
        });

        test('middleware has correct signature (req, res, next)', () => {
            const middleware = createHttpLogger();
            expect(middleware.length).toBeGreaterThanOrEqual(2);
        });

        test('middleware calls next() when invoked', () => {
            const middleware = createHttpLogger();
            const req = {};
            const res = {};
            const next = jest.fn();

            middleware(req, res, next);
            expect(next).toHaveBeenCalled();
        });
    });

    describe('error safety', () => {
        test('logger.info does not throw on object input', () => {
            expect(() => {
                logger.info({ test: 'data' }, 'test message');
            }).not.toThrow();
        });

        test('logger.info does not throw on string input', () => {
            expect(() => {
                logger.info('simple string message');
            }).not.toThrow();
        });

        test('logger.error does not throw on Error object', () => {
            expect(() => {
                logger.error(new Error('test error'), 'error occurred');
            }).not.toThrow();
        });

        test('createChildLogger does not throw on empty module name', () => {
            expect(() => {
                createChildLogger('');
            }).not.toThrow();
        });
    });
});

describe('Logger Redaction Configuration', () => {
    // Note: Full redaction testing requires integration tests with actual pino output
    // These tests verify the configuration is correct

    test('REDACT_PATHS should include password', () => {
        // Verify via the logger config indirectly - if logger exists, config is valid
        expect(logger).toBeDefined();
    });

    test('logger should handle objects with sensitive fields without throwing', () => {
        const sensitiveData = {
            username: 'testuser',
            password: 'secret123',
            token: 'abc123',
            authorization: 'Bearer xyz',
            otp: '123456',
            apiKey: 'key123'
        };

        expect(() => {
            logger.info(sensitiveData, 'testing redaction');
        }).not.toThrow();
    });
});
</file>

<file path="src/utils/sanitize.js">
import sanitizeHtml from 'sanitize-html';

/**
 * Sanitize a string value to prevent stored XSS
 * Strips all HTML tags and attributes
 * 
 * @param {string} value - String to sanitize
 * @returns {string|null} Sanitized string or null if input was null/undefined
 */
export function sanitizeString(value) {
    if (value === null || value === undefined) {
        return value;
    }

    if (typeof value !== 'string') {
        return value;
    }

    // Strip all HTML tags - conservative approach to prevent any XSS
    return sanitizeHtml(value, {
        allowedTags: [],
        allowedAttributes: {},
        disallowedTagsMode: 'recursiveEscape'
    });
}

/**
 * Sanitize specific fields in an object
 * Returns a new object with sanitized fields
 * 
 * @param {Object} obj - Object to sanitize
 * @param {string[]} fields - Array of field names to sanitize
 * @returns {Object} New object with sanitized fields
 */
export function sanitizeObject(obj, fields) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }

    const sanitized = { ...obj };

    for (const field of fields) {
        if (field in sanitized) {
            sanitized[field] = sanitizeString(sanitized[field]);
        }
    }

    return sanitized;
}
</file>

<file path="src/utils/upload.js">
import multer from 'multer';
import { randomUUID } from 'crypto';
import { join } from 'path';
import { existsSync, mkdirSync } from 'fs';
import { config } from '../config/index.js';
import { createChildLogger } from './logger.js';

const uploadLogger = createChildLogger('upload');

// Ensure uploads directory exists
const uploadsDir = join(config.storagePath, 'uploads');
if (!existsSync(uploadsDir)) {
    mkdirSync(uploadsDir, { recursive: true });
    uploadLogger.info({ path: uploadsDir }, 'Created uploads directory');
}

/**
 * Multer disk storage configuration
 * Files are written directly to disk with UUID filenames
 */
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, uploadsDir);
    },
    filename: (req, file, cb) => {
        // Preserve file extension, generate UUID for filename
        const ext = file.originalname.split('.').pop() || 'jpg';
        const filename = `${randomUUID()}.${ext}`;
        cb(null, filename);
    }
});

/**
 * File filter - only allow images
 */
const fileFilter = (req, file, cb) => {
    if (!file.mimetype.startsWith('image/')) {
        const error = new Error('Only image files are allowed');
        error.code = 'INVALID_FILE_TYPE';
        return cb(error, false);
    }
    cb(null, true);
};

/**
 * Shared upload middleware
 * Enforces:
 * - Max file size: 5MB
 * - MIME type: image/* only
 * - Direct disk write (no memory buffering)
 */
export const upload = multer({
    storage,
    limits: {
        fileSize: 5 * 1024 * 1024 // 5MB
    },
    fileFilter
});
</file>

<file path="src/utils/uuid.js">
import crypto from 'crypto';

/**
 * Generate a UUID v4
 * Uses Node.js crypto.randomUUID() for cryptographically secure UUIDs
 */
export function generateUUID() {
    return crypto.randomUUID();
}

/**
 * Generate a URL-safe short ID (for file names)
 */
export function generateShortId() {
    return crypto.randomBytes(16).toString('hex');
}
</file>

<file path="storage/photos/.gitkeep">

</file>

<file path=".env.production">
NODE_ENV=production
DATABASE_PATH=/Users/ronak/Coding/backend/swipe.db
STORAGE_PATH=/Users/ronak/Coding/backend/storage
JWT_SECRET=dev-secret-change-me
PORT=3000
</file>

<file path="NODE_VERSION_REQUIRED.md">
# Node.js Version Requirement

⚠️ **IMPORTANT: This backend requires Node.js v18 LTS**

The `better-sqlite3` package does not compile on Node.js v23.

## Quick Fix

You are currently on **Node.js v23.11.0**. You need to switch to v18.

### Method 1: Using NVM (Recommended)

```bash
# Load NVM if not already loaded
source ~/.nvm/nvm.sh

# Install and use Node.js 18
nvm install 18
nvm use 18

# Verify
node --version  # Should show v18.x.x

# Install dependencies
cd backend
rm -rf node_modules package-lock.json swipe.db*
npm install

# Start server
npm start
```

### Method 2: Use the Setup Script

```bash
cd backend
./setup.sh
```

The script will guide you through the process.

### Method 3: Manual Installation

If you don't have nvm:
1. Download Node.js v18 LTS from https://nodejs.org/
2. Install it
3. Run `npm install` in the backend directory

## After Switching to Node v18

Once on Node v18, the installation should complete successfully:

```bash
npm install    # Should work without errors
npm start      # Server starts on port 3000
```

## Verification

```bash
# Should see v18.x.x
node --version

# Should start without errors
npm start
```

## Why Node v18?

- `better-sqlite3` v9.2.2 requires Node.js v18 or lower
- Node.js v23 introduced breaking changes in native module compilation
- Node.js v18 is the current LTS (Long Term Support) version
- All service files use synchronous API that requires better-sqlite3

## Alternative (Not Recommended)

If you must stay on Node v23, you would need to:
1. Complete the async/await migration in all service files (see IMPLEMENTATION_NOTES.md)
2. Use `sqlite3` package instead of `better-sqlite3`

However, this is significantly more work. **Switching to Node v18 is the fastest path to a working backend.**
</file>

<file path="README.md">
# Swipe Backend Service

> ⚠️ **Requires Node.js v18 LTS** - better-sqlite3 does not compile on Node.js v23+  
> See [NODE_VERSION_REQUIRED.md](NODE_VERSION_REQUIRED.md) for setup instructions.

Local-first backend service for the Swipe Invoice application, built with Node.js, Express, and SQLite.

## Features

- ✅ **Aggregate-based API** - Invoice aggregates assembled from normalized database tables
- ✅ **Transactional operations** - ACID compliance with SQLite WAL mode
- ✅ **Server-side authority** - Totals and balances computed server-side
- ✅ **Idempotency support** - Duplicate prevention via request IDs
- ✅ **Photo storage** - Local filesystem storage with checksums
- ✅ **Audit logging** - Complete audit trail for all mutations
- ✅ **Soft deletes** - Data preservation with recovery capability

## Architecture

The backend implements an **aggregate pattern** where complex business objects (InvoiceAggregate) are assembled from multiple normalized tables:

```
InvoiceAggregate = invoices + invoice_customer_snapshot + invoice_items + invoice_totals + invoice_photos
```

This allows the API to remain clean and business-focused while maintaining relational integrity internally.

## Quick Start

### 1. Install Dependencies

```bash
cd backend
npm install
```

### 2. Configure Environment

```bash
cp .env.example .env
# Edit .env and set your configuration
```

**Required Environment Variables:**
- `DATABASE_PATH` - SQLite database file path
- `STORAGE_PATH` - Photo storage directory
- `JWT_SECRET` - Secret key for JWT authentication
- `PORT` - Server port (default: 3000)

### 3. Start the Server

**Development mode (with auto-reload):**
```bash
npm run dev
```

**Production mode:**
```bash
npm start
```

The server will initialize the database schema automatically on first run.

## API Endpoints

Base URL: `http://localhost:3000/api`

### Health Check
- `GET /health` - Server health status

### Invoices (Aggregate API)
- `GET /api/invoices` - List all invoices (headers only)
- `GET /api/invoices/:id` - Get fully assembled invoice aggregate
- `POST /api/invoices` - Create invoice (supports `X-Request-Id` header for idempotency)
- `PUT /api/invoices/:id` - Update invoice (full replacement)
- `DELETE /api/invoices/:id` - Soft delete invoice
- `POST /api/invoices/:id/photos` - Upload invoice photo
- `DELETE /api/invoices/:invoiceId/photos/:photoId` - Delete invoice photo

### Customers
- `GET /api/customers` - List all customers
- `GET /api/customers/:id` - Get single customer
- `POST /api/customers` - Create customer
- `PUT /api/customers/:id` - Update customer
- `DELETE /api/customers/:id` - Soft delete customer

### Products
- `GET /api/products` - List products (supports `?type=` and `?categoryId=` filters)
- `GET /api/products/:id` - Get product with images
- `POST /api/products` - Create product
- `PUT /api/products/:id` - Update product
- `DELETE /api/products/:id` - Soft delete product
- `POST /api/products/:id/images` - Upload product image
- `DELETE /api/products/:productId/images/:imageId` - Delete product image

### Payments
- `GET /api/payments` - List payments (supports `?partyId=` and `?type=` filters)
- `GET /api/payments/:id` - Get payment with allocations
- `POST /api/payments` - Create payment with allocations (updates invoice statuses and balances)
- `DELETE /api/payments/:id` - Delete payment (recalculates balances)

### Photos
- `GET /api/photos/:id` - Serve photo file

### Settings
- `GET /api/settings` - Get all settings
- `GET /api/settings/:key` - Get single setting
- `PUT /api/settings/:key` - Set a setting value

## Database

The backend uses **SQLite** with:
- **WAL mode** for better concurrency
- **Foreign key constraints** enabled
- **22 normalized tables** for relational integrity
- **Automatic schema initialization**

Database file location: configured via `DATABASE_PATH` (default: `./swipe.db`)

## File Storage

Photos are stored on the local filesystem with:
- UUID-based filenames for uniqueness
- SHA-256 checksums for integrity
- Path abstraction (clients never see filesystem paths)

Storage location: configured via `STORAGE_PATH` (default: `./storage/photos`)

## Key Design Principles

1. **Single Process Architecture** - Better-SQLite3 is synchronous; do not use clustering or worker threads
2. **Server-Side Authority** - All financial calculations performed server-side; client values ignored
3. **Derived Balances** - Balances are computed from ledger, not incremented blindly
4. **Idempotency** - Invoice creation supports request IDs to prevent duplicates
5. **Transactional Integrity** - All mutations happen within database transactions

## Production Deployment

### Environment Variables (Mandatory in Production)

```bash
NODE_ENV=production
DATABASE_PATH=/path/to/production/swipe.db  # REQUIRED
STORAGE_PATH=/path/to/production/photos     # REQUIRED
JWT_SECRET=long-random-secret-key           # REQUIRED
PORT=3000
MIGRATION_ENABLED=false                      # Disable after initial migration
```

### Security Considerations

- Run on local network only (not exposed to internet by default)
- Use Cloudflare Tunnel if remote access is needed (requires explicit setup)
- Set strong `JWT_SECRET` in production
- Keep `MIGRATION_ENABLED=false` after initial data migration

## Error Handling

All errors return consistent JSON format:

```json
{
  "error": "Error message",
  "details": {},
  "requestId": "uuid"
}
```

- **400** - Validation errors
- **404** - Resource not found
- **500** - Internal server error

## Testing

```bash
npm test
```

Tests cover:
- Database initialization
- Invoice aggregate assembly/decomposition
- Transactional integrity
- Payment allocation logic
- Idempotency keys

## Future Enhancements

- [ ] IndexedDB migration endpoint
- [ ] User authentication module
- [ ] Vendor CRUD endpoints
- [ ] Category/subcategory endpoints
- [ ] Bulk import/export
- [ ] Cloud backup sync

## Support

For issues or questions, refer to the implementation plan or contact the development team.

---

**Version:** 1.0.0  
**License:** ISC
</file>

<file path="setup.sh">
#!/bin/bash

# Script to switch to Node.js v18 and install dependencies
# Run this script to complete the backend setup

echo "📦 Backend Setup Script"
echo "======================="
echo ""

# Check if nvm is available
if ! command -v nvm &> /dev/null; then
    echo "⚠️  NVM not found in current shell"
    echo ""
    echo "Please run ONE of these commands in your terminal:"
    echo ""
    echo "Option 1: Load NVM (if installed)"
    echo "  source ~/.nvm/nvm.sh"
    echo "  nvm use 18"
    echo ""
    echo "Option 2: Use system Node (if v18 is installed)"
    echo "  node --version  # Check if already on v18"
    echo ""
    echo "Option 3: Install nvm first"
    echo "  Visit: https://github.com/nvm-sh/nvm#installing-and-updating"
    echo ""
    exit 1
fi

echo "🔄 Switching to Node.js v18..."
nvm use 18

if [ $? -ne 0 ]; then
    echo "❌ Node.js v18 not found"
    echo "📥 Installing Node.js v18..."
    nvm install 18
    nvm use 18
fi

echo ""
echo "✅ Node version: $(node --version)"
echo ""

echo "🧹 Cleaning previous installation..."
rm -rf node_modules package-lock.json swipe.db*

echo "📦 Installing dependencies..."
npm install

if [ $? -eq 0 ]; then
    echo ""
    echo "✅ Setup complete!"
    echo ""
    echo "🚀 Start the server with:"
    echo "   npm start"
    echo ""
else
    echo ""
    echo "❌ Installation failed. Check the error above."
    echo ""
fi
</file>

<file path="specs.md">
---

# Backend Specification

## 1. Purpose (unchanged)

Build a **local-first backend service** for the Swipe Invoice application to replace IndexedDB, support multi-user LAN access, safely store photos, and enable future cloud backup/sync without frontend rewrites.

Frontend is deployed on Vercel and must remain storage-agnostic.

---

## 2. Architectural Principles (unchanged, clarified)

* Frontend **never** accesses database or filesystem directly.
* Backend is the **single source of truth**.
* Storage implementation (SQLite today, Postgres later) must be opaque to clients.
* API exposes **business objects**, not database tables.

---

## 3. Canonical Data Model (NEW – REQUIRED)

The backend maintains a **canonical relational data model** (see attached SQLite DDL).
However, the API does **not** expose tables directly.

Instead, the backend assembles and persists **Aggregate Objects**.

### 3.1 Aggregate Definitions

#### InvoiceAggregate (authoritative API shape)

An invoice is defined as the composition of:

* Invoice header
* Customer snapshot (historical)
* Line items
* Calculated totals
* Attached photos

This aggregate is **assembled on read** and **decomposed transactionally on write**.

The frontend continues to work with a single invoice object and is unaware of internal normalization.

---

## 4. API Assembly & Persistence Rules (NEW)

### Reads

* `GET /invoices/:id`:

  * MUST assemble data from:

    * invoices
    * invoice_customer_snapshot
    * invoice_items
    * invoice_totals
    * invoice_photos
  * MUST return a single InvoiceAggregate object.

### Writes

* `POST /invoices`, `PUT /invoices/:id`:

  * MUST execute inside a single DB transaction.
  * MUST validate payload before any write.
  * MUST recompute derived fields server-side (totals, balances).
  * MUST reject partial persistence (no half-written invoices).

Frontend never writes child entities directly.

---

## 5. Data Ownership & Authority (NEW)

* Backend owns:

  * UUID generation
  * Invoice numbers / sequences
  * Timestamps (`created_at`, `updated_at`)
  * Derived financial fields
* Frontend is treated as an **untrusted client**.
* Client-sent calculated values are ignored or recomputed.

---

## 6. Mutation Semantics (NEW)

* All deletes are **soft deletes** (`deleted_at`).
* Updates use **full-object replacement** or explicit PATCH endpoints.
* Migration and bulk-import endpoints must be **idempotent**.
* IDs are immutable once created.

---

## 7. Storage & Media Rules (unchanged, enforced)

* SQLite runs in WAL mode.
* Photos are stored on local filesystem, never as BLOBs.
* Database file and photo directories must be on local disk only.
* File paths are never exposed directly to clients.

---

## 8. Migration Support (unchanged, clarified)

* Backend provides a one-time migration API to import IndexedDB data.
* Migration logic maps legacy IDs to new UUIDs.
* Embedded objects from IndexedDB are split into canonical tables.
* Migration must be retry-safe and transactional.

---

## 9. Testing & Validation (unchanged)

(Refer to previously defined bare-minimum testing requirements; no changes required.)

---

## 10. Non-Goals (unchanged)

* No direct table-level APIs
* No cloud dependency
* No syncing SQLite files
* No frontend schema assumptions

---

## Reference

**Appendix A:** SQLite Canonical DDL (authoritative storage reference)

---

Below is a **production-grade SQLite DDL** for your **new backend**, derived from your IndexedDB schema but **corrected for relational integrity, migration safety, and future cloud sync**.

This DDL is intentionally:

* **UUID-based**
* **Normalized where correctness matters**
* **Denormalized only where historically necessary**
* **SQLite-safe (WAL, FK, CHECKs)**

---

## 0. Global SQLite settings (must be applied at startup)

```sql
PRAGMA journal_mode = WAL;
PRAGMA synchronous = NORMAL;
PRAGMA foreign_keys = ON;
```

---

## 1. Core reference tables

### users

```sql
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  username TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  role TEXT CHECK(role IN ('ADMIN','USER')) NOT NULL,
  created_at TEXT NOT NULL,
  deleted_at TEXT
);
```

---

## 2. Customers & Vendors

### customers

```sql
CREATE TABLE customers (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  gstin TEXT,
  phone TEXT,
  email TEXT,
  balance REAL NOT NULL DEFAULT 0,
  address_json TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT
);
```

### vendors

```sql
CREATE TABLE vendors (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  gstin TEXT,
  phone TEXT,
  email TEXT,
  balance REAL NOT NULL DEFAULT 0,
  address_json TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT
);
```

---

## 3. Products & Catalog

### categories

```sql
CREATE TABLE categories (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  type TEXT NOT NULL
);
```

### subcategories

```sql
CREATE TABLE subcategories (
  id TEXT PRIMARY KEY,
  category_id TEXT NOT NULL,
  name TEXT NOT NULL,
  FOREIGN KEY (category_id) REFERENCES categories(id)
);
```

### products

```sql
CREATE TABLE products (
  id TEXT PRIMARY KEY,
  type TEXT CHECK(type IN ('product','service')) NOT NULL,
  name TEXT NOT NULL,
  sku TEXT UNIQUE,
  barcode TEXT,
  hsn TEXT,
  category_id TEXT,
  subcategory_id TEXT,
  description TEXT,
  selling_price REAL,
  purchase_price REAL,
  tax_rate REAL,
  unit TEXT,

  metal_json TEXT,
  gemstone_json TEXT,
  design_json TEXT,

  vendor_ref TEXT,
  procurement_date TEXT,
  hallmark_cert TEXT,
  launch_date TEXT,

  show_online INTEGER DEFAULT 0,
  not_for_sale INTEGER DEFAULT 0,

  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT,

  FOREIGN KEY (category_id) REFERENCES categories(id),
  FOREIGN KEY (subcategory_id) REFERENCES subcategories(id)
);
```

### product_images

```sql
CREATE TABLE product_images (
  id TEXT PRIMARY KEY,
  product_id TEXT NOT NULL,
  file_path TEXT NOT NULL,
  checksum TEXT NOT NULL,
  created_at TEXT NOT NULL,
  FOREIGN KEY (product_id) REFERENCES products(id)
);
```

---

## 4. Invoices (canonical structure)

### invoices

```sql
CREATE TABLE invoices (
  id TEXT PRIMARY KEY,
  invoice_number TEXT UNIQUE NOT NULL,
  customer_id TEXT,
  type TEXT CHECK(type IN ('INVOICE','PROFORMA','LENDING')) NOT NULL,
  status TEXT CHECK(status IN ('PAID','PARTIAL','UNPAID','PENDING')) NOT NULL,
  date TEXT NOT NULL,
  due_date TEXT,
  place_of_supply TEXT,

  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT,

  FOREIGN KEY (customer_id) REFERENCES customers(id)
);
```

### invoice_customer_snapshot (historical truth)

```sql
CREATE TABLE invoice_customer_snapshot (
  invoice_id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  phone TEXT,
  gstin TEXT,
  address_json TEXT,
  FOREIGN KEY (invoice_id) REFERENCES invoices(id)
);
```

### invoice_items

```sql
CREATE TABLE invoice_items (
  id TEXT PRIMARY KEY,
  invoice_id TEXT NOT NULL,
  product_id TEXT,
  description TEXT,
  quantity REAL NOT NULL,
  rate REAL NOT NULL,
  tax_rate REAL,
  weight_json TEXT,
  amount_json TEXT,

  FOREIGN KEY (invoice_id) REFERENCES invoices(id),
  FOREIGN KEY (product_id) REFERENCES products(id)
);
```

### invoice_totals

```sql
CREATE TABLE invoice_totals (
  invoice_id TEXT PRIMARY KEY,
  subtotal REAL NOT NULL,
  tax_total REAL NOT NULL,
  cgst REAL,
  sgst REAL,
  igst REAL,
  round_off REAL,
  grand_total REAL NOT NULL,
  FOREIGN KEY (invoice_id) REFERENCES invoices(id)
);
```

### invoice_photos

```sql
CREATE TABLE invoice_photos (
  id TEXT PRIMARY KEY,
  invoice_id TEXT NOT NULL,
  file_path TEXT NOT NULL,
  checksum TEXT NOT NULL,
  created_at TEXT NOT NULL,
  FOREIGN KEY (invoice_id) REFERENCES invoices(id)
);
```

---

## 5. Purchases (mirrors invoices)

### purchases

```sql
CREATE TABLE purchases (
  id TEXT PRIMARY KEY,
  purchase_number TEXT UNIQUE NOT NULL,
  vendor_id TEXT,
  status TEXT CHECK(status IN ('PAID','PARTIAL','UNPAID')) NOT NULL,
  date TEXT NOT NULL,
  due_date TEXT,

  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT,

  FOREIGN KEY (vendor_id) REFERENCES vendors(id)
);
```

---

## 6. Payments & Allocations

### payments

```sql
CREATE TABLE payments (
  id TEXT PRIMARY KEY,
  transaction_number TEXT UNIQUE NOT NULL,
  date TEXT NOT NULL,
  type TEXT CHECK(type IN ('IN','OUT')) NOT NULL,
  party_type TEXT CHECK(party_type IN ('CUSTOMER','VENDOR')) NOT NULL,
  party_id TEXT NOT NULL,
  amount REAL NOT NULL,
  mode TEXT,
  notes TEXT,
  created_at TEXT NOT NULL
);
```

### payment_allocations

```sql
CREATE TABLE payment_allocations (
  id TEXT PRIMARY KEY,
  payment_id TEXT NOT NULL,
  invoice_id TEXT NOT NULL,
  amount REAL NOT NULL,
  FOREIGN KEY (payment_id) REFERENCES payments(id),
  FOREIGN KEY (invoice_id) REFERENCES invoices(id)
);
```

---

## 7. Sequences & Settings

### sequences

```sql
CREATE TABLE sequences (
  key TEXT PRIMARY KEY,
  value INTEGER NOT NULL
);
```

### settings

```sql
CREATE TABLE settings (
  key TEXT PRIMARY KEY,
  value_json TEXT NOT NULL
);
```

---

## 8. Audit & Operational Logs

### audit_logs

```sql
CREATE TABLE audit_logs (
  id TEXT PRIMARY KEY,
  entity_type TEXT NOT NULL,
  entity_id TEXT NOT NULL,
  action TEXT NOT NULL,
  details TEXT,
  created_at TEXT NOT NULL
);
```

### attendance_logs

```sql
CREATE TABLE attendance_logs (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  login_date TEXT NOT NULL,
  login_at TEXT NOT NULL,
  logout_at TEXT,
  created_at TEXT NOT NULL
);
```

### bulk_upload_logs

```sql
CREATE TABLE bulk_upload_logs (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  file_name TEXT NOT NULL,
  total_records INTEGER,
  success_count INTEGER,
  failure_count INTEGER,
  created_at TEXT NOT NULL
);
```

---
</file>

<file path="verify_create_customer.js">
import http from 'http';

const data = JSON.stringify({
    name: 'Test Customer',
    phone: '1234567890',
    email: 'test@example.com'
});

const options = {
    hostname: 'localhost',
    port: 3000,
    path: '/api/customers',
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length
    }
};

const req = http.request(options, (res) => {
    let responseBody = '';

    res.on('data', (chunk) => {
        responseBody += chunk;
    });

    res.on('end', () => {
        console.log(`Status Code: ${res.statusCode}`);
        console.log(`Response Body: ${responseBody}`);
    });
});

req.on('error', (error) => {
    console.error(`Error: ${error.message}`);
});

req.write(data);
req.end();
</file>

<file path=".adminjs/bundle.js">
(function(){"use strict";AdminJS.UserComponents={}})();
</file>

<file path="src/db/schema.sql">
-- SQLite Canonical DDL for Swipe Invoice Backend
-- Multi-Tenant Architecture: All business data is scoped by shop_id
-- This schema is the authoritative storage reference

-- 0. Global SQLite settings (must be applied at startup via PRAGMA)
-- PRAGMA journal_mode = WAL;
-- PRAGMA synchronous = NORMAL;
-- PRAGMA foreign_keys = ON;

-- 1. Shops (Tenants)
CREATE TABLE IF NOT EXISTS shops (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  created_at TEXT NOT NULL
);

-- 2. Users (belong to exactly one shop)
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  shop_id TEXT NOT NULL,
  phone TEXT NOT NULL UNIQUE,
  name TEXT,
  role TEXT CHECK(role IN ('ADMIN','SALES')) NOT NULL,
  created_at TEXT NOT NULL,
  deleted_at TEXT,
  FOREIGN KEY (shop_id) REFERENCES shops(id)
);

-- 3. Customers (shop-scoped)
CREATE TABLE IF NOT EXISTS customers (
  id TEXT PRIMARY KEY,
  shop_id TEXT NOT NULL,
  name TEXT NOT NULL,
  gstin TEXT,
  phone TEXT,
  email TEXT,
  balance REAL NOT NULL DEFAULT 0,
  address_json TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT,
  FOREIGN KEY (shop_id) REFERENCES shops(id)
);

-- 4. Vendors (shop-scoped)
CREATE TABLE IF NOT EXISTS vendors (
  id TEXT PRIMARY KEY,
  shop_id TEXT NOT NULL,
  name TEXT NOT NULL,
  gstin TEXT,
  phone TEXT,
  email TEXT,
  balance REAL NOT NULL DEFAULT 0,
  address_json TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT,
  FOREIGN KEY (shop_id) REFERENCES shops(id)
);

-- 5. Categories (shop-scoped)
CREATE TABLE IF NOT EXISTS categories (
  id TEXT PRIMARY KEY,
  shop_id TEXT NOT NULL,
  name TEXT NOT NULL,
  type TEXT NOT NULL,
  FOREIGN KEY (shop_id) REFERENCES shops(id)
);

-- 6. Subcategories
CREATE TABLE IF NOT EXISTS subcategories (
  id TEXT PRIMARY KEY,
  category_id TEXT NOT NULL,
  name TEXT NOT NULL,
  FOREIGN KEY (category_id) REFERENCES categories(id)
);

-- 7. Products (shop-scoped)
CREATE TABLE IF NOT EXISTS products (
  id TEXT PRIMARY KEY,
  shop_id TEXT NOT NULL,
  type TEXT CHECK(type IN ('product','service')) NOT NULL,
  name TEXT NOT NULL,
  sku TEXT,
  barcode TEXT,
  hsn TEXT,
  category_id TEXT,
  subcategory_id TEXT,
  description TEXT,
  selling_price REAL,
  purchase_price REAL,
  tax_rate REAL,
  unit TEXT,

  metal_json TEXT,
  gemstone_json TEXT,
  design_json TEXT,

  vendor_ref TEXT,
  procurement_date TEXT,
  hallmark_cert TEXT,
  launch_date TEXT,

  show_online INTEGER DEFAULT 0,
  not_for_sale INTEGER DEFAULT 0,

  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT,

  FOREIGN KEY (shop_id) REFERENCES shops(id),
  FOREIGN KEY (category_id) REFERENCES categories(id),
  FOREIGN KEY (subcategory_id) REFERENCES subcategories(id)
);

-- 8. Product Images
CREATE TABLE IF NOT EXISTS product_images (
  id TEXT PRIMARY KEY,
  product_id TEXT NOT NULL,
  file_path TEXT NOT NULL,
  checksum TEXT NOT NULL,
  created_at TEXT NOT NULL,
  FOREIGN KEY (product_id) REFERENCES products(id)
);

-- 9. Invoices (shop-scoped)
CREATE TABLE IF NOT EXISTS invoices (
  id TEXT PRIMARY KEY,
  shop_id TEXT NOT NULL,
  invoice_number TEXT NOT NULL,
  customer_id TEXT,
  type TEXT CHECK(type IN ('INVOICE','PROFORMA','LENDING')) NOT NULL,
  status TEXT CHECK(status IN ('PAID','PARTIAL','UNPAID','PENDING')) NOT NULL,
  date TEXT NOT NULL,
  due_date TEXT,
  place_of_supply TEXT,

  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT,

  FOREIGN KEY (shop_id) REFERENCES shops(id),
  FOREIGN KEY (customer_id) REFERENCES customers(id),
  UNIQUE(shop_id, invoice_number)
);

-- 10. Invoice Customer Snapshot (historical truth)
CREATE TABLE IF NOT EXISTS invoice_customer_snapshot (
  invoice_id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  phone TEXT,
  gstin TEXT,
  address_json TEXT,
  FOREIGN KEY (invoice_id) REFERENCES invoices(id)
);

-- 11. Invoice Items
CREATE TABLE IF NOT EXISTS invoice_items (
  id TEXT PRIMARY KEY,
  invoice_id TEXT NOT NULL,
  product_id TEXT,
  description TEXT,
  quantity REAL NOT NULL,
  rate REAL NOT NULL,
  tax_rate REAL,
  weight_json TEXT,
  amount_json TEXT,

  FOREIGN KEY (invoice_id) REFERENCES invoices(id),
  FOREIGN KEY (product_id) REFERENCES products(id)
);

-- 12. Invoice Totals
CREATE TABLE IF NOT EXISTS invoice_totals (
  invoice_id TEXT PRIMARY KEY,
  subtotal REAL NOT NULL,
  tax_total REAL NOT NULL,
  cgst REAL,
  sgst REAL,
  igst REAL,
  round_off REAL,
  grand_total REAL NOT NULL,
  FOREIGN KEY (invoice_id) REFERENCES invoices(id)
);

-- 13. Invoice Photos
CREATE TABLE IF NOT EXISTS invoice_photos (
  id TEXT PRIMARY KEY,
  invoice_id TEXT NOT NULL,
  file_path TEXT NOT NULL,
  checksum TEXT NOT NULL,
  created_at TEXT NOT NULL,
  FOREIGN KEY (invoice_id) REFERENCES invoices(id)
);

-- 14. Purchases (shop-scoped)
CREATE TABLE IF NOT EXISTS purchases (
  id TEXT PRIMARY KEY,
  shop_id TEXT NOT NULL,
  purchase_number TEXT NOT NULL,
  vendor_id TEXT,
  status TEXT CHECK(status IN ('PAID','PARTIAL','UNPAID')) NOT NULL,
  date TEXT NOT NULL,
  due_date TEXT,

  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  deleted_at TEXT,

  FOREIGN KEY (shop_id) REFERENCES shops(id),
  FOREIGN KEY (vendor_id) REFERENCES vendors(id),
  UNIQUE(shop_id, purchase_number)
);

-- 15. Payments (shop-scoped)
CREATE TABLE IF NOT EXISTS payments (
  id TEXT PRIMARY KEY,
  shop_id TEXT NOT NULL,
  transaction_number TEXT NOT NULL,
  date TEXT NOT NULL,
  type TEXT CHECK(type IN ('IN','OUT')) NOT NULL,
  party_type TEXT CHECK(party_type IN ('CUSTOMER','VENDOR')) NOT NULL,
  party_id TEXT NOT NULL,
  amount REAL NOT NULL,
  mode TEXT,
  notes TEXT,
  created_at TEXT NOT NULL,
  FOREIGN KEY (shop_id) REFERENCES shops(id),
  UNIQUE(shop_id, transaction_number)
);

-- 16. Payment Allocations
CREATE TABLE IF NOT EXISTS payment_allocations (
  id TEXT PRIMARY KEY,
  payment_id TEXT NOT NULL,
  invoice_id TEXT NOT NULL,
  amount REAL NOT NULL,
  FOREIGN KEY (payment_id) REFERENCES payments(id),
  FOREIGN KEY (invoice_id) REFERENCES invoices(id)
);

-- 17. Sequences (per-shop, composite key)
CREATE TABLE IF NOT EXISTS sequences (
  shop_id TEXT NOT NULL,
  key TEXT NOT NULL,
  value INTEGER NOT NULL,
  PRIMARY KEY (shop_id, key),
  FOREIGN KEY (shop_id) REFERENCES shops(id)
);

-- 18. Settings (shop-scoped)
CREATE TABLE IF NOT EXISTS settings (
  shop_id TEXT NOT NULL,
  key TEXT NOT NULL,
  value_json TEXT NOT NULL,
  PRIMARY KEY (shop_id, key),
  FOREIGN KEY (shop_id) REFERENCES shops(id)
);

-- 19. Audit Logs (shop-scoped with actor tracking)
CREATE TABLE IF NOT EXISTS audit_logs (
  id TEXT PRIMARY KEY,
  shop_id TEXT NOT NULL,
  actor_user_id TEXT NOT NULL,
  entity_type TEXT NOT NULL,
  entity_id TEXT NOT NULL,
  action TEXT NOT NULL,
  details TEXT,
  created_at TEXT NOT NULL,
  FOREIGN KEY (shop_id) REFERENCES shops(id),
  FOREIGN KEY (actor_user_id) REFERENCES users(id)
);

-- 20. Attendance Logs
CREATE TABLE IF NOT EXISTS attendance_logs (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  login_date TEXT NOT NULL,
  login_at TEXT NOT NULL,
  logout_at TEXT,
  created_at TEXT NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 21. Bulk Upload Logs
CREATE TABLE IF NOT EXISTS bulk_upload_logs (
  id TEXT PRIMARY KEY,
  shop_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  file_name TEXT NOT NULL,
  total_records INTEGER,
  success_count INTEGER,
  failure_count INTEGER,
  created_at TEXT NOT NULL,
  FOREIGN KEY (shop_id) REFERENCES shops(id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 22. Idempotency Keys (for duplicate prevention)
CREATE TABLE IF NOT EXISTS idempotency_keys (
  request_id TEXT PRIMARY KEY,
  shop_id TEXT NOT NULL,
  entity_type TEXT NOT NULL,
  entity_id TEXT NOT NULL,
  created_at TEXT NOT NULL,
  FOREIGN KEY (shop_id) REFERENCES shops(id)
);

-- 23. Migration ID Map (for IndexedDB migration)
CREATE TABLE IF NOT EXISTS migration_id_map (
  old_id TEXT NOT NULL,
  new_uuid TEXT NOT NULL,
  entity_type TEXT NOT NULL,
  PRIMARY KEY (old_id, entity_type)
);

-- Indexes for performance (shop_id scoping)
CREATE INDEX IF NOT EXISTS idx_users_shop ON users(shop_id);
CREATE INDEX IF NOT EXISTS idx_users_phone ON users(phone);
CREATE INDEX IF NOT EXISTS idx_customers_shop ON customers(shop_id);
CREATE INDEX IF NOT EXISTS idx_customers_deleted ON customers(deleted_at);
CREATE INDEX IF NOT EXISTS idx_vendors_shop ON vendors(shop_id);
CREATE INDEX IF NOT EXISTS idx_vendors_deleted ON vendors(deleted_at);
CREATE INDEX IF NOT EXISTS idx_categories_shop ON categories(shop_id);
CREATE INDEX IF NOT EXISTS idx_products_shop ON products(shop_id);
CREATE INDEX IF NOT EXISTS idx_products_deleted ON products(deleted_at);
CREATE INDEX IF NOT EXISTS idx_invoices_shop ON invoices(shop_id);
CREATE INDEX IF NOT EXISTS idx_invoices_deleted ON invoices(deleted_at);
CREATE INDEX IF NOT EXISTS idx_invoices_customer ON invoices(customer_id);
CREATE INDEX IF NOT EXISTS idx_purchases_shop ON purchases(shop_id);
CREATE INDEX IF NOT EXISTS idx_payments_shop ON payments(shop_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_shop ON audit_logs(shop_id);
CREATE INDEX IF NOT EXISTS idx_invoice_items_invoice ON invoice_items(invoice_id);
CREATE INDEX IF NOT EXISTS idx_invoice_photos_invoice ON invoice_photos(invoice_id);
CREATE INDEX IF NOT EXISTS idx_product_images_product ON product_images(product_id);
CREATE INDEX IF NOT EXISTS idx_payment_allocations_payment ON payment_allocations(payment_id);
CREATE INDEX IF NOT EXISTS idx_payment_allocations_invoice ON payment_allocations(invoice_id);
</file>

<file path="src/middleware/auth.js">
import jwt from 'jsonwebtoken';
import { config } from '../config/index.js';

/**
 * JWT authentication middleware
 * Verifies JWT token and attaches user (with shopId and role) to request
 */
export function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
        return res.status(401).json({
            error: 'Authentication required',
            requestId: req.requestId
        });
    }

    try {
        const decoded = jwt.verify(token, config.jwtSecret);
        // JWT payload: { userId, shopId, role }
        req.user = decoded;
        next();
    } catch (error) {
        return res.status(403).json({
            error: 'Invalid or expired token',
            requestId: req.requestId
        });
    }
}

/**
 * Role-based access control middleware
 * Requires authenticateToken middleware to run first
 */
export function requireRole(...roles) {
    return (req, res, next) => {
        if (!req.user) {
            return res.status(401).json({
                error: 'Authentication required',
                requestId: req.requestId
            });
        }

        if (!roles.includes(req.user.role)) {
            return res.status(403).json({
                error: 'Insufficient permissions',
                requestId: req.requestId
            });
        }

        next();
    };
}

/**
 * Admin-only middleware
 * Blocks access for non-ADMIN users
 */
export function adminOnly(req, res, next) {
    if (!req.user) {
        return res.status(401).json({
            error: 'Authentication required',
            requestId: req.requestId
        });
    }

    if (req.user.role !== 'ADMIN') {
        return res.status(403).json({
            error: 'Admin access required',
            requestId: req.requestId
        });
    }

    next();
}

/**
 * Block DELETE operations for SALES role
 * Use on routes where SALES users should only have read/create/update access
 */
export function noDeleteForSales(req, res, next) {
    if (req.method === 'DELETE' && req.user && req.user.role === 'SALES') {
        return res.status(403).json({
            error: 'Delete operation not permitted for sales users',
            requestId: req.requestId
        });
    }
    next();
}
</file>

<file path="src/middleware/rateLimiter.js">
import rateLimit from 'express-rate-limit';

/**
 * Strict rate limiter for authentication endpoints
 * 10 requests per 10 minutes per IP address
 */
export const strictAuthRateLimiter = rateLimit({
    windowMs: 10 * 60 * 1000, // 10 minutes
    max: 10, // Limit each IP to 10 requests per windowMs
    message: {
        error: 'Too many authentication requests from this IP, please try again later.',
        requestId: undefined // Will be populated by handler
    },
    standardHeaders: true, // Return rate limit info in `RateLimit-*` headers
    legacyHeaders: false, // Disable `X-RateLimit-*` headers
    // Custom handler to include requestId
    handler: (req, res) => {
        res.status(429).json({
            error: 'Too many authentication requests from this IP, please try again later.',
            requestId: req.requestId
        });
    }
});

/**
 * General rate limiter for all API endpoints
 * 100 requests per 15 minutes per IP address
 */
export const generalApiRateLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per windowMs
    message: {
        error: 'Too many requests from this IP, please try again later.',
        requestId: undefined
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
        res.status(429).json({
            error: 'Too many requests from this IP, please try again later.',
            requestId: req.requestId
        });
    }
});
</file>

<file path="src/models/InvoiceAggregate.js">
/**
 * InvoiceAggregate - Domain Object / DTO
 * 
 * This is NOT an ORM model. It represents the canonical business object shape
 * that the API exposes to clients.
 * 
 * Internally, this aggregate is assembled from 5 tables:
 * - invoices
 * - invoice_customer_snapshot
 * - invoice_items
 * - invoice_totals
 * - invoice_photos
 */

import { toRupees } from '../utils/calculator.js';

/**
 * Create an invoice aggregate object from database rows
 * This is the READ assembly operation
 * 
 * @param {Object} invoice - Invoice header row
 * @param {Object} customer - Customer snapshot row
 * @param {Array} items - Invoice item rows
 * @param {Object} totals - Invoice totals row
 * @param {Array} photos - Invoice photo rows
 * @returns {Object} Assembled InvoiceAggregate
 */
export function assembleInvoiceAggregate(invoice, customer, items, totals, photos) {
    return {
        id: invoice.id,
        invoiceNumber: invoice.invoice_number,
        type: invoice.type,
        status: invoice.status,
        date: invoice.date,
        dueDate: invoice.due_date,
        placeOfSupply: invoice.place_of_supply,

        customer: customer ? {
            id: invoice.customer_id,
            name: customer.name,
            phone: customer.phone,
            gstin: customer.gstin,
            address: customer.address_json ? JSON.parse(customer.address_json) : null
        } : null,

        items: items.map(item => ({
            id: item.id,
            productId: item.product_id,
            description: item.description,
            quantity: item.quantity,
            rate: item.rate,
            taxRate: item.tax_rate,
            weight: item.weight_json ? JSON.parse(item.weight_json) : null,
            amount: item.amount_json ? JSON.parse(item.amount_json) : null
        })),

        totals: totals ? {
            subtotal: toRupees(totals.subtotal_paisa),
            taxTotal: toRupees(totals.tax_total_paisa),
            cgst: toRupees(totals.cgst_paisa),
            sgst: toRupees(totals.sgst_paisa),
            igst: toRupees(totals.igst_paisa),
            roundOff: toRupees(totals.round_off_paisa),
            grandTotal: toRupees(totals.grand_total_paisa)
        } : null,

        photos: photos.map(photo => ({
            id: photo.id,
            url: `/api/photos/${photo.id}`,
            createdAt: photo.created_at
        })),

        createdAt: invoice.created_at,
        updatedAt: invoice.updated_at
    };
}

/**
 * Decompose an invoice aggregate for database storage
 * This prepares the aggregate for WRITE operations
 * 
 * @param {Object} aggregate - Invoice aggregate from client
 * @param {Object} computedValues - Server-computed values (totals, etc.)
 * @returns {Object} Decomposed data ready for database insertion
 */
export function decomposeInvoiceAggregate(aggregate, computedValues) {
    return {
        invoice: {
            customer_id: aggregate.customerId,
            type: aggregate.type,
            status: aggregate.status || 'UNPAID',
            date: aggregate.date,
            due_date: aggregate.dueDate || null,
            place_of_supply: aggregate.placeOfSupply || null
        },

        customerSnapshot: {
            name: aggregate.customer.name,
            phone: aggregate.customer.phone || null,
            gstin: aggregate.customer.gstin || null,
            address_json: aggregate.customer.address ? JSON.stringify(aggregate.customer.address) : null
        },

        items: aggregate.items.map(item => ({
            product_id: item.productId || null,
            description: item.description || null,
            quantity: item.quantity,
            rate: item.rate,
            tax_rate: item.taxRate || null,
            weight_json: item.weight ? JSON.stringify(item.weight) : null,
            amount_json: item.amount ? JSON.stringify(item.amount) : null
        })),

        totals: computedValues.totals
    };
}
</file>

<file path="src/routes/ops.js">
import express from 'express';
import multer from 'multer';
import { randomUUID } from 'crypto';
import { join, dirname } from 'path';
import { existsSync, mkdirSync, unlinkSync } from 'fs';
import { fileURLToPath } from 'url';
import { authenticateToken } from '../middleware/auth.js';
import { injectShopScope } from '../middleware/shopScope.js';
import { createFullBackup, validateBackupFilename, getBackupPath, restoreFromBackup } from '../services/backupService.js';
import { logAction } from '../services/auditService.js';
import { createChildLogger } from '../utils/logger.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const router = express.Router();
const opsLogger = createChildLogger('ops');

// Ensure temp uploads directory exists
const tempUploadsDir = join(__dirname, '../../storage/temp_uploads');
if (!existsSync(tempUploadsDir)) {
    mkdirSync(tempUploadsDir, { recursive: true });
}

/**
 * Multer configuration for backup ZIP uploads
 * Uses disk storage to avoid memory issues with large files
 */
const restoreStorage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, tempUploadsDir);
    },
    filename: (req, file, cb) => {
        const filename = `restore_${randomUUID()}.zip`;
        cb(null, filename);
    }
});

const restoreUpload = multer({
    storage: restoreStorage,
    limits: {
        fileSize: 100 * 1024 * 1024 // 100MB max
    },
    fileFilter: (req, file, cb) => {
        // Accept only ZIP files
        if (file.mimetype === 'application/zip' ||
            file.mimetype === 'application/x-zip-compressed' ||
            file.originalname.toLowerCase().endsWith('.zip')) {
            cb(null, true);
        } else {
            const error = new Error('Only ZIP files are allowed');
            error.code = 'INVALID_FILE_TYPE';
            cb(error, false);
        }
    }
});

// All routes require authentication and shop scope
router.use(authenticateToken);
router.use(injectShopScope);

/**
 * @swagger
 * /api/ops/backup:
 *   post:
 *     summary: Create a full backup (DB + storage) as ZIP
 *     tags: [Operations]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Backup created successfully
 *       409:
 *         description: Backup already in progress
 *       500:
 *         description: Backup creation failed
 */
router.post('/backup', async (req, res, next) => {
    try {
        const metadata = await createFullBackup();

        // Log backup creation to audit trail
        logAction(
            req.shopId,
            'SYSTEM',
            metadata.filename,
            'BACKUP_CREATED',
            { sizeBytes: metadata.sizeBytes },
            req.user.userId
        );

        res.json({
            success: true,
            ...metadata
        });
    } catch (error) {
        // Handle concurrent backup error specifically
        if (error.statusCode === 409) {
            return res.status(409).json({
                error: error.message,
                requestId: req.requestId
            });
        }
        next(error);
    }
});

/**
 * @swagger
 * /api/ops/backup/{filename}:
 *   get:
 *     summary: Download a backup ZIP file
 *     tags: [Operations]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: filename
 *         required: true
 *         schema:
 *           type: string
 *         description: Backup filename
 *     responses:
 *       200:
 *         description: Backup file download
 *       400:
 *         description: Invalid filename
 *       404:
 *         description: Backup file not found
 */
router.get('/backup/:filename', (req, res, next) => {
    try {
        const { filename } = req.params;

        // Validate filename to prevent path traversal
        if (!validateBackupFilename(filename)) {
            return res.status(400).json({
                error: 'Invalid backup filename',
                requestId: req.requestId
            });
        }

        // Get safe backup path
        const backupPath = getBackupPath(filename);

        // Check if file exists
        if (!existsSync(backupPath)) {
            return res.status(404).json({
                error: 'Backup file not found',
                requestId: req.requestId
            });
        }

        // Stream file to client
        res.download(backupPath, filename, (err) => {
            if (err) {
                next(err);
            }
        });
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/ops/restore:
 *   post:
 *     summary: Restore from a backup ZIP file (ADMIN only)
 *     tags: [Operations]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               backup:
 *                 type: string
 *                 format: binary
 *                 description: Backup ZIP file
 *     responses:
 *       200:
 *         description: Restore completed, server will restart
 *       400:
 *         description: Invalid backup file or format
 *       403:
 *         description: Admin access required
 *       409:
 *         description: Restore or backup already in progress
 *       415:
 *         description: Only ZIP files allowed
 *       500:
 *         description: Restore failed
 */
router.post('/restore', restoreUpload.single('backup'), async (req, res, next) => {
    let uploadedFilePath = null;

    try {
        // ADMIN-only check
        if (req.user.role !== 'ADMIN') {
            return res.status(403).json({
                error: 'Admin access required for restore operations',
                requestId: req.requestId
            });
        }

        // Check if file was uploaded
        if (!req.file) {
            return res.status(400).json({
                error: 'No backup file uploaded',
                requestId: req.requestId
            });
        }

        uploadedFilePath = req.file.path;
        opsLogger.info({
            uploadedFilePath,
            originalName: req.file.originalname,
            sizeBytes: req.file.size
        }, 'Backup file uploaded for restore');

        // Perform restore
        const metadata = await restoreFromBackup(uploadedFilePath, {
            shopId: req.shopId,
            userId: req.user.userId
        });

        // Clean up uploaded file
        try {
            unlinkSync(uploadedFilePath);
            opsLogger.info({ uploadedFilePath }, 'Cleaned up uploaded backup file');
        } catch (cleanupErr) {
            opsLogger.warn({ cleanupErr }, 'Failed to clean up uploaded file');
        }

        // Send success response
        res.json(metadata);

        // Schedule server exit after response is sent
        // Use setImmediate to ensure response is flushed
        opsLogger.info('Scheduling server exit after restore');
        setImmediate(() => {
            opsLogger.info('Server exiting after successful restore. Restart required.');
            process.exit(0);
        });

    } catch (error) {
        // Clean up uploaded file on error
        if (uploadedFilePath && existsSync(uploadedFilePath)) {
            try {
                unlinkSync(uploadedFilePath);
            } catch (cleanupErr) {
                opsLogger.warn({ cleanupErr }, 'Failed to clean up uploaded file after error');
            }
        }

        // Handle specific error codes
        if (error.statusCode === 400) {
            return res.status(400).json({
                error: error.message,
                requestId: req.requestId
            });
        }
        if (error.statusCode === 409) {
            return res.status(409).json({
                error: error.message,
                requestId: req.requestId
            });
        }
        if (error.code === 'INVALID_FILE_TYPE') {
            return res.status(415).json({
                error: 'Only ZIP files are allowed',
                requestId: req.requestId
            });
        }
        if (error.code === 'LIMIT_FILE_SIZE') {
            return res.status(400).json({
                error: 'File too large. Maximum size is 100MB',
                requestId: req.requestId
            });
        }

        next(error);
    }
});

// Handle multer errors globally for this router
router.use((error, req, res, next) => {
    if (error.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({
            error: 'File too large. Maximum size is 100MB',
            requestId: req.requestId
        });
    }
    if (error.code === 'INVALID_FILE_TYPE') {
        return res.status(415).json({
            error: 'Only ZIP files are allowed',
            requestId: req.requestId
        });
    }
    next(error);
});

export default router;
</file>

<file path="src/routes/photos.js">
import express from 'express';
import { readFileSync } from 'fs';
import { getDatabase } from '../db/init.js';
import { getAbsolutePath } from '../services/fileService.js';
import { authenticateToken } from '../middleware/auth.js';
import { injectShopScope } from '../middleware/shopScope.js';

const router = express.Router();

// All routes require authentication and shop scope
router.use(authenticateToken);
router.use(injectShopScope);

/**
 * @swagger
 * /api/photos/{id}:
 *   get:
 *     summary: Get photo file
 *     description: Works for both invoice_photos and product_images. Requires authentication.
 *     tags: [Photos]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *     responses:
 *       200:
 *         description: Image file
 *         content:
 *           image/*:
 *             schema:
 *               type: string
 *               format: binary
 *       401:
 *         description: Unauthorized - missing or invalid token
 *       404:
 *         description: Photo not found or not accessible
 */
router.get('/:id', (req, res, next) => {
    try {
        const db = getDatabase();
        const photoId = req.params.id;
        const shopId = req.shopId;

        // Check invoice_photos with shop scope validation
        let photo = db.prepare(`
            SELECT ip.file_path FROM invoice_photos ip
            JOIN invoices i ON ip.invoice_id = i.id
            WHERE ip.id = ? AND i.shop_id = ?
        `).get(photoId, shopId);

        // If not found, check product_images with shop scope validation
        if (!photo) {
            photo = db.prepare(`
                SELECT pi.file_path FROM product_images pi
                JOIN products p ON pi.product_id = p.id
                WHERE pi.id = ? AND p.shop_id = ?
            `).get(photoId, shopId);
        }

        if (!photo) {
            return res.status(404).json({
                error: 'Photo not found',
                requestId: req.requestId
            });
        }

        // Get absolute path (never expose to client)
        const absolutePath = getAbsolutePath(photo.file_path);

        // Read and serve file
        const fileBuffer = readFileSync(absolutePath);

        // Set appropriate content type
        const ext = photo.file_path.split('.').pop().toLowerCase();
        const contentTypes = {
            jpg: 'image/jpeg',
            jpeg: 'image/jpeg',
            png: 'image/png',
            gif: 'image/gif',
            webp: 'image/webp'
        };

        res.setHeader('Content-Type', contentTypes[ext] || 'application/octet-stream');
        res.send(fileBuffer);
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="src/services/fileService.js">
import { readFileSync, unlinkSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import { config } from '../config/index.js';
import { calculateChecksum } from '../utils/checksum.js';
import { createChildLogger } from '../utils/logger.js';

const fileLogger = createChildLogger('file');

// Ensure storage directory exists
if (!existsSync(config.storagePath)) {
    mkdirSync(config.storagePath, { recursive: true });
    fileLogger.info({ path: config.storagePath }, 'Created storage directory');
}

/**
 * Save a photo file to disk
 * File is already on disk from multer diskStorage
 * This function just calculates checksum and returns metadata
 * 
 * @param {string} filename - Filename (already on disk in uploads/)
 * @returns {Object} { filePath, checksum }
 */
export function savePhoto(filename) {
    // File already written by multer to uploads/ directory
    const absolutePath = join(config.storagePath, 'uploads', filename);

    // Read file to calculate checksum
    // Note: readFileSync is acceptable here - only called once per upload
    const buffer = readFileSync(absolutePath);
    const checksum = calculateChecksum(buffer);

    // Return relative path (never expose absolute path to client)
    return {
        filePath: filename,  // Store only the filename, not full path
        checksum
    };
}

/**
 * Get absolute file path from stored filename
 * Internal use only - never expose to client
 * 
 * @param {string} filename - Stored filename
 * @returns {string} Absolute path
 */
export function getAbsolutePath(filename) {
    return join(config.storagePath, 'uploads', filename);
}

/**
 * Delete a photo from disk
 * 
 * @param {string} filename - Stored filename
 */
export function deletePhoto(filename) {
    const absolutePath = getAbsolutePath(filename);

    if (existsSync(absolutePath)) {
        unlinkSync(absolutePath);
    }
}

/**
 * Check if a photo exists
 * 
 * @param {string} filename - Stored filename
 * @returns {boolean}
 */
export function photoExists(filename) {
    return existsSync(getAbsolutePath(filename));
}
</file>

<file path="src/services/sequenceService.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase } from '../db/init.js';

/**
 * Get next sequence number for invoice, purchase, or payment
 * Thread-safe via SQLite's transaction isolation
 * Sequences are per-shop to allow multiple shops to have their own numbering
 * 
 * @param {string} shopId - Shop UUID
 * @param {string} key - Sequence key
 * @returns {number} Next sequence number
 */
export function getNextSequence(shopId, key) {
    const db = getDatabase();

    const stmt = db.prepare(`
        UPDATE sequences SET value = value + 1 
        WHERE shop_id = ? AND key = ? 
        RETURNING value
    `);
    const result = stmt.get(shopId, key);

    if (!result) {
        throw new Error(`Sequence not found: ${key} for shop ${shopId}`);
    }

    return result.value;
}

/**
 * Generate formatted invoice number (per-shop unique)
 * Format: INV-YYYY-NNNN
 * @param {string} shopId - Shop UUID
 */
export function generateInvoiceNumber(shopId) {
    const seq = getNextSequence(shopId, 'invoice_seq');
    const year = new Date().getFullYear();
    return `INV-${year}-${String(seq).padStart(4, '0')}`;
}

/**
 * Generate formatted purchase number (per-shop unique)
 * Format: PUR-YYYY-NNNN
 * @param {string} shopId - Shop UUID
 */
export function generatePurchaseNumber(shopId) {
    const seq = getNextSequence(shopId, 'purchase_seq');
    const year = new Date().getFullYear();
    return `PUR-${year}-${String(seq).padStart(4, '0')}`;
}

/**
 * Generate formatted payment/transaction number (per-shop unique)
 * Format: PAY-YYYY-NNNN
 * @param {string} shopId - Shop UUID
 */
export function generatePaymentNumber(shopId) {
    const seq = getNextSequence(shopId, 'payment_seq');
    const year = new Date().getFullYear();
    return `PAY-${year}-${String(seq).padStart(4, '0')}`;
}

/**
 * Reset a sequence (use with caution)
 * @param {string} shopId - Shop UUID
 * @param {string} key - Sequence key
 * @param {number} value - New value
 */
export function resetSequence(shopId, key, value = 1) {
    const db = getDatabase();
    const stmt = db.prepare('UPDATE sequences SET value = ? WHERE shop_id = ? AND key = ?');
    stmt.run(value, shopId, key);
}
</file>

<file path="src/services/userService.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase, transaction } from '../db/init.js';
import { generateUUID } from '../utils/uuid.js';
import { createShop, getShop, initializeShopSequences } from './shopService.js';
import jwt from 'jsonwebtoken';
import { config } from '../config/index.js';
import { createChildLogger } from '../utils/logger.js';

const userLogger = createChildLogger('user');

// Static OTP for local development
const DEV_OTP = '111111';

/**
 * Request OTP for phone number
 * NOTE: Does NOT create users. Use /api/setup/bootstrap for initial setup.
 */
export function requestOTP(phone) {
    const db = getDatabase();

    // Check if user exists
    let user = db.prepare('SELECT * FROM users WHERE phone = ? AND deleted_at IS NULL').get(phone);

    if (!user) {
        userLogger.debug({ phone }, 'Phone number not registered');
    }

    // Log OTP generation WITHOUT the actual OTP value (security)
    userLogger.debug({ phone }, 'OTP generated for phone number');

    return {
        success: true,
        message: 'OTP sent successfully',
        phone
    };
}

/**
 * Verify OTP and return JWT
 * NOTE: Does NOT auto-create shops. Use /api/setup/bootstrap for initial setup.
 */
export function verifyOTP(phone, otp) {
    const db = getDatabase();

    // Verify OTP (static for dev)
    if (otp !== DEV_OTP) {
        throw { statusCode: 401, message: 'Invalid OTP' };
    }

    // Find user by phone
    let user = db.prepare('SELECT * FROM users WHERE phone = ? AND deleted_at IS NULL').get(phone);

    if (!user) {
        // User not registered - do NOT auto-create
        throw {
            statusCode: 403,
            message: 'User not registered. Contact your shop admin to get access.'
        };
    }

    // Generate JWT token with shopId and role
    const token = jwt.sign(
        {
            userId: user.id,
            shopId: user.shop_id,
            role: user.role
        },
        config.jwtSecret,
        { expiresIn: '30d' }
    );

    return {
        token,
        user: {
            id: user.id,
            phone: user.phone,
            name: user.name,
            role: user.role,
            shopId: user.shop_id
        }
    };
}

/**
 * Get user by ID with shop info
 * Used for /api/auth/me endpoint
 */
export function getUser(userId) {
    const db = getDatabase();

    const user = db.prepare(`
        SELECT u.id, u.phone, u.name, u.role, u.shop_id, u.created_at,
               s.id as shop_id, s.name as shop_name
        FROM users u
        JOIN shops s ON u.shop_id = s.id
        WHERE u.id = ? AND u.deleted_at IS NULL
    `).get(userId);

    if (!user) return null;

    return {
        id: user.id,
        phone: user.phone,
        name: user.name,
        role: user.role,
        created_at: user.created_at,
        shop: {
            id: user.shop_id,
            name: user.shop_name
        }
    };
}

/**
 * List all users in a shop (admin only)
 */
export function listUsers(shopId) {
    const db = getDatabase();
    return db.prepare(`
        SELECT id, phone, name, role, created_at 
        FROM users 
        WHERE shop_id = ? AND deleted_at IS NULL
        ORDER BY created_at DESC
    `).all(shopId);
}

/**
 * Create a user in a shop (for adding SALES users)
 * Only ADMIN can do this
 */
export function createUser(shopId, data) {
    const db = getDatabase();
    const userId = generateUUID();
    const now = new Date().toISOString();

    // Check if phone already exists
    const existing = db.prepare('SELECT id FROM users WHERE phone = ?').get(data.phone);
    if (existing) {
        throw { statusCode: 400, message: 'Phone number already registered' };
    }

    db.prepare(`
        INSERT INTO users (id, shop_id, phone, name, role, created_at)
        VALUES (?, ?, ?, ?, ?, ?)
    `).run(userId, shopId, data.phone, data.name || null, data.role || 'SALES', now);

    userLogger.info({ userId, shopId, phone: data.phone, role: data.role }, 'Created new user');

    return getUser(userId);
}
</file>

<file path="src/utils/calculator.js">
/**
 * Calculate invoice totals using integer paisa arithmetic
 * Server-side authority - never trust client calculations
 * 
 * @param {Array} items - Invoice line items
 * @param {string} placeOfSupply - State code for GST calculation
 * @returns {Object} Calculation results in paisa (integers)
 */
export function calculateInvoiceTotals(items, placeOfSupply = null) {
    let subtotalPaisa = 0;
    let taxTotalPaisa = 0;
    let cgstPaisa = 0;
    let sgstPaisa = 0;
    let igstPaisa = 0;

    items.forEach(item => {
        // Convert rate to paisa FIRST to avoid floating-point errors
        const ratePaisa = Math.round(item.rate * 100);
        const lineTotalPaisa = item.quantity * ratePaisa;
        subtotalPaisa += lineTotalPaisa;

        if (item.taxRate) {
            const lineTaxPaisa = Math.round((lineTotalPaisa * item.taxRate) / 100);
            taxTotalPaisa += lineTaxPaisa;

            // Simplified CGST/SGST vs IGST logic
            // In production, compare placeOfSupply with business GSTIN state
            const isIntraState = true; // TODO: Implement proper state comparison

            if (isIntraState) {
                cgstPaisa += Math.round(lineTaxPaisa / 2);
                sgstPaisa += Math.round(lineTaxPaisa / 2);
            } else {
                igstPaisa += lineTaxPaisa;
            }
        }
    });

    const grandTotalBeforeRound = subtotalPaisa + taxTotalPaisa;
    // Round to nearest rupee in paisa
    const grandTotalPaisa = Math.round(grandTotalBeforeRound / 100) * 100;
    const roundOffPaisa = grandTotalPaisa - grandTotalBeforeRound;

    return {
        subtotalPaisa,
        taxTotalPaisa,
        cgstPaisa,
        sgstPaisa,
        igstPaisa,
        roundOffPaisa,
        grandTotalPaisa
    };
}

/**
 * Convert paisa (integer) to rupees (decimal string) for API responses
 * 
 * @param {number} paisa - Amount in paisa (integer)
 * @returns {string} Amount in rupees with 2 decimal places
 */
export function toRupees(paisa) {
    if (paisa === null || paisa === undefined) {
        return '0.00';
    }
    return (paisa / 100).toFixed(2);
}

/**
 * Recalculate customer/vendor balance from ledger using integer paisa
 * Balances are derived, not authoritative
 * 
 * @param {Object} db - Database instance
 * @param {string} partyId - Customer or vendor ID
 * @param {string} partyType - 'CUSTOMER' or 'VENDOR'
 * @returns {number} Calculated balance in paisa (integer)
 */
export function recalculateBalance(db, partyId, partyType) {
    // Sum all invoices for this party (in paisa)
    const invoiceStmt = db.prepare(`
    SELECT COALESCE(SUM(it.grand_total_paisa), 0) as total_invoiced
    FROM invoices i
    JOIN invoice_totals it ON i.id = it.invoice_id
    WHERE i.customer_id = ? AND i.deleted_at IS NULL
  `);

    const { total_invoiced } = invoiceStmt.get(partyId);

    // Sum all payments for this party (in paisa)
    const paymentStmt = db.prepare(`
    SELECT COALESCE(SUM(amount_paisa), 0) as total_paid
    FROM payments
    WHERE party_id = ? AND party_type = ?
  `);

    const { total_paid } = paymentStmt.get(partyId, partyType);

    return total_invoiced - total_paid; // Integer paisa
}
</file>

<file path="src/utils/logger.js">
/**
 * Centralized Pino Logger
 * 
 * Features:
 * - Environment-driven log level (LOG_LEVEL env var)
 * - Pretty printing for dev, JSON for prod
 * - File transport with rotation in production
 * - Sensitive field redaction
 * - Request ID correlation
 * - Error-safe (never throws, never blocks)
 */

import pino from 'pino';
import pinoHttp from 'pino-http';
import { existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Configuration
const isDev = process.env.NODE_ENV !== 'production';
const logLevel = process.env.LOG_LEVEL || 'info';

// Ensure logs directory exists in production
const logsDir = join(__dirname, '../../logs');
if (!isDev && !existsSync(logsDir)) {
    try {
        mkdirSync(logsDir, { recursive: true });
    } catch (err) {
        console.error('Failed to create logs directory:', err.message);
    }
}

// Sensitive fields to redact
const REDACT_PATHS = [
    'password',
    'token',
    'authorization',
    'otp',
    'secret',
    'apiKey',
    'cookie',
    'set-cookie',
    'req.headers.authorization',
    'req.headers.cookie',
    'res.headers["set-cookie"]'
];

/**
 * Create base pino options
 */
function createLoggerOptions() {
    const baseOptions = {
        level: logLevel,
        redact: {
            paths: REDACT_PATHS,
            censor: '[REDACTED]'
        },
        // Add timestamp in ISO format
        timestamp: pino.stdTimeFunctions.isoTime,
        // Base bindings for all logs
        base: {
            pid: process.pid
        }
    };

    // Custom formatters only work with pino-pretty (dev mode)
    // In production with transport.targets, we use default numeric levels
    if (isDev) {
        baseOptions.formatters = {
            level: (label) => ({ level: label }),
            bindings: (bindings) => bindings
        };
    }

    return baseOptions;
}

/**
 * Create transport configuration
 */
function createTransport() {
    if (isDev) {
        // Pretty print for development
        return {
            target: 'pino-pretty',
            options: {
                colorize: true,
                translateTime: 'SYS:standard',
                ignore: 'pid,hostname'
            }
        };
    }

    // Production: multi-stream to stdout + rotating file
    return {
        targets: [
            // Stdout (for Docker/PM2 log collection)
            {
                target: 'pino/file',
                options: { destination: 1 }, // stdout
                level: logLevel
            },
            // File with rotation (7 days retention)
            {
                target: 'pino/file',
                options: {
                    destination: join(logsDir, 'app.log'),
                    mkdir: true
                },
                level: logLevel
            }
        ]
    };
}

/**
 * Safe logger wrapper that never throws
 */
function createSafeLogger() {
    try {
        const options = createLoggerOptions();
        const transport = createTransport();

        return pino({
            ...options,
            transport
        });
    } catch (err) {
        // Fallback to console if pino fails
        console.error('Failed to initialize pino logger:', err.message);
        return {
            info: (...args) => console.log('[INFO]', ...args),
            warn: (...args) => console.warn('[WARN]', ...args),
            error: (...args) => console.error('[ERROR]', ...args),
            debug: (...args) => console.debug('[DEBUG]', ...args),
            fatal: (...args) => console.error('[FATAL]', ...args),
            child: () => createSafeLogger()
        };
    }
}

// Main logger instance
export const logger = createSafeLogger();

/**
 * Create a child logger with module context
 * 
 * @param {string} module - Module name for context
 * @returns {pino.Logger} Child logger instance
 */
export function createChildLogger(module) {
    try {
        return logger.child({ module });
    } catch (err) {
        console.error('Failed to create child logger:', err.message);
        return logger;
    }
}

/**
 * Create HTTP logging middleware
 * Binds request ID and logs request/response
 * 
 * @returns {Function} Express middleware
 */
export function createHttpLogger() {
    try {
        return pinoHttp({
            logger,
            // Use existing request ID if present
            genReqId: (req) => req.id || req.headers['x-request-id'] || undefined,
            // Custom log level based on status code
            customLogLevel: (req, res, err) => {
                if (res.statusCode >= 500 || err) return 'error';
                if (res.statusCode >= 400) return 'warn';
                return 'info';
            },
            // Custom success message
            customSuccessMessage: (req, res) => {
                return `${req.method} ${req.url} ${res.statusCode}`;
            },
            // Custom error message
            customErrorMessage: (req, res, err) => {
                return `${req.method} ${req.url} ${res.statusCode} - ${err.message}`;
            },
            // Redact sensitive headers
            redact: REDACT_PATHS,
            // Skip health check spam
            autoLogging: {
                ignore: (req) => req.url === '/health'
            }
        });
    } catch (err) {
        console.error('Failed to create HTTP logger:', err.message);
        // Return no-op middleware
        return (req, res, next) => next();
    }
}

export default logger;
</file>

<file path=".gitignore">
# Dependencies
node_modules/
backend/node_modules/

# Environment variables
.env
backend/.env
backend/.env.production

# Local databases
*.db
*.db-shm
*.db-wal
backend/*.db
backend/*.db-shm
backend/*.db-wal

# Storage
storage/photos/*
backend/storage/photos/*
!storage/photos/.gitkeep
!backend/storage/photos/.gitkeep

# OS files
.DS_Store
backend/.DS_Store
</file>

<file path="src/config/index.js">
import dotenv from 'dotenv';

dotenv.config();

export const config = {
  host: process.env.HOST || '0.0.0.0',
  port: process.env.PORT || 3000,
  nodeEnv: process.env.NODE_ENV || 'development',
  databasePath: process.env.DATABASE_PATH || './swipe.db',
  storagePath: process.env.STORAGE_PATH || './storage/photos',
  jwtSecret: process.env.JWT_SECRET || 'dev-secret-change-in-production',
  setupSecret: process.env.SETUP_SECRET || 'dev-setup-secret',
  migrationEnabled: process.env.MIGRATION_ENABLED === 'true',
};

// Validate required configuration
if (config.nodeEnv === 'production') {
  if (!process.env.DATABASE_PATH) {
    throw new Error('DATABASE_PATH is required in production');
  }
  if (!process.env.STORAGE_PATH) {
    throw new Error('STORAGE_PATH is required in production');
  }
  if (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'dev-secret-change-in-production') {
    throw new Error('JWT_SECRET must be set in production');
  }
}
</file>

<file path="src/db/init.js">
import Database from 'better-sqlite3';
import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { config } from '../config/index.js';
import { createChildLogger } from '../utils/logger.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const dbLogger = createChildLogger('db');

let db = null;

/**
 * Initialize database connection and schema
 * This function is idempotent - safe to call multiple times
 */
export function initDatabase() {
    if (db) {
        return db;
    }

    dbLogger.info({ path: config.databasePath }, 'Initializing database');

    // Create database connection with busy timeout to handle WAL contention
    db = new Database(config.databasePath, { timeout: 5000 });

    // Apply critical SQLite settings
    db.pragma('journal_mode = WAL');
    db.pragma('synchronous = NORMAL');
    db.pragma('foreign_keys = ON');

    dbLogger.info('Applied SQLite settings (WAL mode, foreign keys ON, timeout 5s)');

    // Read and execute schema
    const schemaPath = join(__dirname, 'schema.sql');
    const schema = readFileSync(schemaPath, 'utf8');

    // Execute entire schema at once (better-sqlite3 handles multiple statements)
    db.exec(schema);

    dbLogger.info('Database schema initialized');

    // Note: Sequences are now per-shop and initialized when a shop is created
    // See shopService.js initializeShopSequences()

    return db;
}

/**
 * Get database instance
 * WARNING: This assumes initDatabase() has been called
 */
export function getDatabase() {
    if (!db) {
        throw new Error('Database not initialized. Call initDatabase() first.');
    }
    return db;
}

/**
 * Close database connection (for graceful shutdown)
 */
export function closeDatabase() {
    if (db) {
        db.close();
        db = null;
        dbLogger.info('Database connection closed');
    }
}

/**
 * Execute a function within a transaction
 * Automatically rolls back on error
 * 
 * @param {Function} fn - Function to execute in transaction
 * @returns {*} Result of the function
 */
export function transaction(fn) {
    const db = getDatabase();

    try {
        db.exec('BEGIN TRANSACTION');
        const result = fn(db);
        db.exec('COMMIT');
        return result;
    } catch (error) {
        db.exec('ROLLBACK');
        throw error;
    }
}
</file>

<file path="src/routes/auth.js">
import express from 'express';
import { requestOTP, verifyOTP, getUser, createUser, listUsers } from '../services/userService.js';
import { authenticateToken, adminOnly } from '../middleware/auth.js';
import { injectShopScope } from '../middleware/shopScope.js';
import { strictAuthRateLimiter } from '../middleware/rateLimiter.js';

const router = express.Router();

/**
 * @swagger
 * /api/auth/request-otp:
 *   post:
 *     summary: Request OTP for phone number
 *     tags: [Auth]
 *     security: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [phone]
 *             properties:
 *               phone:
 *                 type: string
 *     responses:
 *       200:
 *         description: OTP requested
 */
router.post('/request-otp', strictAuthRateLimiter, (req, res, next) => {
    try {
        const { phone } = req.body;

        if (!phone) {
            return res.status(400).json({
                error: 'Phone number is required',
                requestId: req.requestId
            });
        }

        const result = requestOTP(phone);
        res.json(result);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/auth/verify-otp:
 *   post:
 *     summary: Verify OTP and get JWT token
 *     tags: [Auth]
 *     security: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [phone, otp]
 *             properties:
 *               phone:
 *                 type: string
 *               otp:
 *                 type: string
 *     responses:
 *       200:
 *         description: Login successful
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 token:
 *                   type: string
 *                 user:
 *                   type: object
 */
router.post('/verify-otp', strictAuthRateLimiter, (req, res, next) => {
    try {
        const { phone, otp } = req.body;

        if (!phone || !otp) {
            return res.status(400).json({
                error: 'Phone number and OTP are required',
                requestId: req.requestId
            });
        }

        const result = verifyOTP(phone, otp);
        res.json(result);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/auth/login:
 *   post:
 *     summary: Verify OTP and get JWT token
 *     tags: [Auth]
 *     security: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - phone
 *               - otp
 *             properties:
 *               phone:
 *                 type: string
 *                 description: User phone number
 *                 example: "1234567890"
 *               otp:
 *                 type: string
 *                 description: One-time password
 *                 example: "123456"
 *     responses:
 *       200:
 *         description: Login successful
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 token:
 *                   type: string
 *                   description: JWT access token
 *                 user:
 *                   type: object
 *                   description: User details
 *       400:
 *         description: Missing phone or OTP
 *       401:
 *         description: Invalid OTP
 */
router.post('/login', strictAuthRateLimiter, (req, res, next) => {
    try {
        const { phone, otp } = req.body;

        if (!phone || !otp) {
            return res.status(400).json({
                error: 'Phone number and OTP are required',
                requestId: req.requestId
            });
        }

        const result = verifyOTP(phone, otp);
        res.json(result);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/auth/me:
 *   get:
 *     summary: Get current user info (requires auth)
 *     tags: [Auth]
 *     responses:
 *       200:
 *         description: User profile
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: string
 *                 phone:
 *                   type: string
 *                 role:
 *                   type: string
 */
router.get('/me', authenticateToken, (req, res, next) => {
    try {
        const user = getUser(req.user.userId);
        if (!user) {
            return res.status(404).json({
                error: 'User not found',
                requestId: req.requestId
            });
        }
        res.json(user);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/auth/users:
 *   get:
 *     summary: List all users in the shop (ADMIN only)
 *     tags: [Auth]
 *     responses:
 *       200:
 *         description: List of users
 */
router.get('/users', authenticateToken, injectShopScope, adminOnly, (req, res, next) => {
    try {
        const users = listUsers(req.shopId);
        res.json(users);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/auth/users:
 *   post:
 *     summary: Create a new user in the shop (ADMIN only)
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [phone]
 *             properties:
 *               phone:
 *                 type: string
 *               name:
 *                 type: string
 *               role:
 *                 type: string
 *                 enum: [ADMIN, SALES]
 *     responses:
 *       201:
 *         description: User created
 */
router.post('/users', authenticateToken, injectShopScope, adminOnly, (req, res, next) => {
    try {
        const { phone, name, role } = req.body;

        if (!phone) {
            return res.status(400).json({
                error: 'Phone number is required',
                requestId: req.requestId
            });
        }

        if (role && !['ADMIN', 'SALES'].includes(role)) {
            return res.status(400).json({
                error: 'Role must be ADMIN or SALES',
                requestId: req.requestId
            });
        }

        const user = createUser(req.shopId, { phone, name, role });
        res.status(201).json(user);
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="src/routes/categories.js">
import express from 'express';
import {
    createCategory,
    getCategory,
    listCategories,
    updateCategory,
    deleteCategory,
    createSubcategory,
    deleteSubcategory
} from '../services/categoryService.js';
import { authenticateToken, adminOnly } from '../middleware/auth.js';
import { injectShopScope } from '../middleware/shopScope.js';

const router = express.Router();

// All routes require authentication and shop scope
router.use(authenticateToken);
router.use(injectShopScope);

/**
 * @swagger
 * /api/categories:
 *   get:
 *     summary: List all categories with subcategories
 *     tags: [Categories]
 */
router.get('/', (req, res, next) => {
    try {
        const categories = listCategories(req.shopId);
        res.json(categories);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/categories/{id}:
 *   get:
 *     summary: Get single category
 *     tags: [Categories]
 */
router.get('/:id', (req, res, next) => {
    try {
        const category = getCategory(req.shopId, req.params.id);
        if (!category) {
            return res.status(404).json({ error: 'Category not found', requestId: req.requestId });
        }
        res.json(category);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/categories:
 *   post:
 *     summary: Create new category
 *     tags: [Categories]
 */
router.post('/', (req, res, next) => {
    try {
        const category = createCategory(req.shopId, req.body, req.user.userId);
        res.status(201).json(category);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/categories/{id}:
 *   put:
 *     summary: Update category
 *     tags: [Categories]
 */
router.put('/:id', (req, res, next) => {
    try {
        const category = updateCategory(req.shopId, req.params.id, req.body, req.user.userId);
        res.json(category);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/categories/{id}:
 *   delete:
 *     summary: Delete category (ADMIN only)
 *     tags: [Categories]
 */
router.delete('/:id', adminOnly, (req, res, next) => {
    try {
        deleteCategory(req.shopId, req.params.id, req.user.userId);
        res.status(204).send();
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/categories/{id}/subcategories:
 *   post:
 *     summary: Add subcategory to category
 *     tags: [Categories]
 */
router.post('/:id/subcategories', (req, res, next) => {
    try {
        const subcategory = createSubcategory(req.shopId, req.params.id, req.body, req.user.userId);
        res.status(201).json(subcategory);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/categories/{categoryId}/subcategories/{subcategoryId}:
 *   delete:
 *     summary: Delete subcategory (ADMIN only)
 *     tags: [Categories]
 */
router.delete('/:categoryId/subcategories/:subcategoryId', adminOnly, (req, res, next) => {
    try {
        deleteSubcategory(req.shopId, req.params.subcategoryId, req.user.userId);
        res.status(204).send();
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="src/routes/customers.js">
import express from 'express';
import {
    createCustomer,
    getCustomer,
    listCustomers,
    updateCustomer,
    deleteCustomer
} from '../services/customerService.js';
import { validate, schemas } from '../middleware/validator.js';
import { authenticateToken, adminOnly } from '../middleware/auth.js';
import { injectShopScope } from '../middleware/shopScope.js';

const router = express.Router();

// All routes require authentication and shop scope
router.use(authenticateToken);
router.use(injectShopScope);

/**
 * @swagger
 * /api/customers:
 *   get:
 *     summary: List all customers
 *     tags: [Customers]
 *     responses:
 *       200:
 *         description: List of customers
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Customer'
 */
router.get('/', (req, res, next) => {
    try {
        const customers = listCustomers(req.shopId);
        res.json(customers);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/customers/{id}:
 *   get:
 *     summary: Get single customer
 *     tags: [Customers]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *     responses:
 *       200:
 *         description: Customer details
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Customer'
 *       404:
 *         description: Customer not found
 */
router.get('/:id', (req, res, next) => {
    try {
        const customer = getCustomer(req.shopId, req.params.id);

        if (!customer) {
            return res.status(404).json({
                error: 'Customer not found',
                requestId: req.requestId
            });
        }

        res.json(customer);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/customers:
 *   post:
 *     summary: Create new customer
 *     tags: [Customers]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/Customer'
 *     responses:
 *       201:
 *         description: Customer created
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Customer'
 */
router.post('/', validate(schemas.customer), (req, res, next) => {
    try {
        const customer = createCustomer(req.shopId, req.body, req.user.userId);
        res.status(201).json(customer);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/customers/{id}:
 *   put:
 *     summary: Update customer
 *     tags: [Customers]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/Customer'
 *     responses:
 *       200:
 *         description: Customer updated
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Customer'
 */
router.put('/:id', validate(schemas.customer), (req, res, next) => {
    try {
        const customer = updateCustomer(req.shopId, req.params.id, req.body, req.user.userId);
        res.json(customer);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/customers/{id}:
 *   delete:
 *     summary: Soft delete customer (ADMIN only)
 *     tags: [Customers]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *     responses:
 *       204:
 *         description: Customer deleted
 */
router.delete('/:id', adminOnly, (req, res, next) => {
    try {
        deleteCustomer(req.shopId, req.params.id, req.user.userId);
        res.status(204).send();
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="src/routes/payments.js">
import express from 'express';
import {
    createPayment,
    getPayment,
    listPayments,
    deletePayment
} from '../services/paymentService.js';
import { validate, schemas } from '../middleware/validator.js';
import { authenticateToken, adminOnly } from '../middleware/auth.js';
import { injectShopScope } from '../middleware/shopScope.js';

const router = express.Router();

// All routes require authentication and shop scope
router.use(authenticateToken);
router.use(injectShopScope);

/**
 * @swagger
 * /api/payments:
 *   get:
 *     summary: List payments with optional filters
 *     tags: [Payments]
 */
router.get('/', (req, res, next) => {
    try {
        const filters = {
            partyId: req.query.partyId,
            type: req.query.type
        };

        const payments = listPayments(req.shopId, filters);
        res.json(payments);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/payments/{id}:
 *   get:
 *     summary: Get payment with allocations
 *     tags: [Payments]
 */
router.get('/:id', (req, res, next) => {
    try {
        const payment = getPayment(req.shopId, req.params.id);

        if (!payment) {
            return res.status(404).json({
                error: 'Payment not found',
                requestId: req.requestId
            });
        }

        res.json(payment);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/payments:
 *   post:
 *     summary: Create payment with allocations
 *     tags: [Payments]
 */
router.post('/', validate(schemas.payment), (req, res, next) => {
    try {
        const payment = createPayment(req.shopId, req.body, req.user.userId);
        res.status(201).json(payment);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/payments/{id}:
 *   delete:
 *     summary: Delete payment and recalculate balances (ADMIN only)
 *     tags: [Payments]
 */
router.delete('/:id', adminOnly, (req, res, next) => {
    try {
        deletePayment(req.shopId, req.params.id, req.user.userId);
        res.status(204).send();
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="src/routes/purchases.js">
import express from 'express';
import {
    createPurchase,
    getPurchase,
    listPurchases,
    updatePurchase,
    deletePurchase
} from '../services/purchaseService.js';
import { authenticateToken, adminOnly } from '../middleware/auth.js';
import { injectShopScope } from '../middleware/shopScope.js';

const router = express.Router();

// All routes require authentication and shop scope
router.use(authenticateToken);
router.use(injectShopScope);

/**
 * @swagger
 * /api/purchases:
 *   get:
 *     summary: List purchases
 *     tags: [Purchases]
 */
router.get('/', (req, res, next) => {
    try {
        const filters = {
            vendorId: req.query.vendorId,
            status: req.query.status
        };
        const purchases = listPurchases(req.shopId, filters);
        res.json(purchases);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/purchases/{id}:
 *   get:
 *     summary: Get single purchase
 *     tags: [Purchases]
 */
router.get('/:id', (req, res, next) => {
    try {
        const purchase = getPurchase(req.shopId, req.params.id);
        if (!purchase) {
            return res.status(404).json({ error: 'Purchase not found', requestId: req.requestId });
        }
        res.json(purchase);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/purchases:
 *   post:
 *     summary: Create new purchase
 *     tags: [Purchases]
 */
router.post('/', (req, res, next) => {
    try {
        const purchase = createPurchase(req.shopId, req.body, req.user.userId);
        res.status(201).json(purchase);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/purchases/{id}:
 *   put:
 *     summary: Update purchase
 *     tags: [Purchases]
 */
router.put('/:id', (req, res, next) => {
    try {
        const purchase = updatePurchase(req.shopId, req.params.id, req.body, req.user.userId);
        res.json(purchase);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/purchases/{id}:
 *   delete:
 *     summary: Soft delete purchase (ADMIN only)
 *     tags: [Purchases]
 */
router.delete('/:id', adminOnly, (req, res, next) => {
    try {
        deletePurchase(req.shopId, req.params.id, req.user.userId);
        res.status(204).send();
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="src/routes/settings.js">
import express from 'express';
import { getSetting, setSetting, getAllSettings } from '../services/settingsService.js';
import { authenticateToken, adminOnly } from '../middleware/auth.js';
import { injectShopScope } from '../middleware/shopScope.js';

const router = express.Router();

// All routes require authentication and shop scope
router.use(authenticateToken);
router.use(injectShopScope);

/**
 * @swagger
 * /api/settings:
 *   get:
 *     summary: Get all settings
 *     tags: [Settings]
 */
router.get('/', (req, res, next) => {
    try {
        const settings = getAllSettings(req.shopId);
        res.json(settings);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/settings/{key}:
 *   get:
 *     summary: Get single setting
 *     tags: [Settings]
 */
router.get('/:key', (req, res, next) => {
    try {
        const value = getSetting(req.shopId, req.params.key);

        if (value === null) {
            return res.status(404).json({
                error: 'Setting not found',
                requestId: req.requestId
            });
        }

        res.json({ key: req.params.key, value });
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/settings/{key}:
 *   put:
 *     summary: Set a setting (ADMIN only)
 *     tags: [Settings]
 */
router.put('/:key', adminOnly, (req, res, next) => {
    try {
        const { value } = req.body;

        if (value === undefined) {
            return res.status(400).json({
                error: 'Value is required',
                requestId: req.requestId
            });
        }

        setSetting(req.shopId, req.params.key, value, req.user.userId);
        res.json({ key: req.params.key, value });
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="src/routes/vendors.js">
import express from 'express';
import {
    createVendor,
    getVendor,
    listVendors,
    updateVendor,
    deleteVendor
} from '../services/vendorService.js';
import { validate, schemas } from '../middleware/validator.js';
import { authenticateToken, adminOnly } from '../middleware/auth.js';
import { injectShopScope } from '../middleware/shopScope.js';

const router = express.Router();

// All routes require authentication and shop scope
router.use(authenticateToken);
router.use(injectShopScope);

/**
 * @swagger
 * /api/vendors:
 *   get:
 *     summary: List all vendors
 *     tags: [Vendors]
 *     responses:
 *       200:
 *         description: List of vendors
 */
router.get('/', (req, res, next) => {
    try {
        const vendors = listVendors(req.shopId);
        res.json(vendors);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/vendors/{id}:
 *   get:
 *     summary: Get single vendor
 *     tags: [Vendors]
 */
router.get('/:id', (req, res, next) => {
    try {
        const vendor = getVendor(req.shopId, req.params.id);
        if (!vendor) {
            return res.status(404).json({ error: 'Vendor not found', requestId: req.requestId });
        }
        res.json(vendor);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/vendors:
 *   post:
 *     summary: Create new vendor
 *     tags: [Vendors]
 */
router.post('/', validate(schemas.vendor), (req, res, next) => {
    try {
        const vendor = createVendor(req.shopId, req.body, req.user.userId);
        res.status(201).json(vendor);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/vendors/{id}:
 *   put:
 *     summary: Update vendor
 *     tags: [Vendors]
 */
router.put('/:id', validate(schemas.vendor), (req, res, next) => {
    try {
        const vendor = updateVendor(req.shopId, req.params.id, req.body, req.user.userId);
        res.json(vendor);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/vendors/{id}:
 *   delete:
 *     summary: Soft delete vendor (ADMIN only)
 *     tags: [Vendors]
 */
router.delete('/:id', adminOnly, (req, res, next) => {
    try {
        deleteVendor(req.shopId, req.params.id, req.user.userId);
        res.status(204).send();
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="src/services/auditService.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase } from '../db/init.js';
import { generateUUID } from '../utils/uuid.js';

/**
 * Log an action to audit trail
 * 
 * @param {string} shopId - Shop UUID (required)
 * @param {string} entityType - Type of entity (required)
 * @param {string} entityId - ID of the entity (required)
 * @param {string} action - Action performed (required)
 * @param {*} details - Additional details (optional)
 * @param {string} actorUserId - User who performed the action (REQUIRED)
 */
export function logAction(shopId, entityType, entityId, action, details = null, actorUserId) {
  const db = getDatabase();

  if (!actorUserId) {
    throw new Error('actorUserId is required for audit logging');
  }

  const stmt = db.prepare(`
    INSERT INTO audit_logs (id, shop_id, actor_user_id, entity_type, entity_id, action, details, created_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `);

  stmt.run(
    generateUUID(),
    shopId,
    actorUserId,
    entityType,
    entityId,
    action,
    details ? JSON.stringify(details) : null,
    new Date().toISOString()
  );
}

/**
 * Get audit logs for a specific entity
 * 
 * @param {string} shopId - Shop UUID
 * @param {string} entityType - Type of entity
 * @param {string} entityId - ID of the entity
 * @returns {Array} Array of audit log entries
 */
export function getEntityLogs(shopId, entityType, entityId) {
  const db = getDatabase();

  const stmt = db.prepare(`
    SELECT * FROM audit_logs
    WHERE shop_id = ? AND entity_type = ? AND entity_id = ?
    ORDER BY created_at DESC
  `);

  const rows = stmt.all(shopId, entityType, entityId);

  return rows.map(row => ({
    ...row,
    details: row.details ? JSON.parse(row.details) : null
  }));
}

/**
 * Get recent audit logs for a shop
 * 
 * @param {string} shopId - Shop UUID
 * @param {number} limit - Number of logs to retrieve
 * @returns {Array} Array of recent audit log entries
 */
export function getRecentLogs(shopId, limit = 100) {
  const db = getDatabase();

  const stmt = db.prepare(`
    SELECT * FROM audit_logs
    WHERE shop_id = ?
    ORDER BY created_at DESC
    LIMIT ?
  `);

  const rows = stmt.all(shopId, limit);

  return rows.map(row => ({
    ...row,
    details: row.details ? JSON.parse(row.details) : null
  }));
}
</file>

<file path="src/services/settingsService.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase } from '../db/init.js';
import { logAction } from './auditService.js';

/**
 * Get a setting value for a shop
 */
export function getSetting(shopId, key) {
    const db = getDatabase();
    const stmt = db.prepare('SELECT value_json FROM settings WHERE shop_id = ? AND key = ?');
    const result = stmt.get(shopId, key);

    if (!result) return null;
    return JSON.parse(result.value_json);
}

/**
 * Set a setting value for a shop
 * @param {string} shopId - Shop UUID
 * @param {string} key - Setting key
 * @param {*} value - Value to store
 * @param {string} actorUserId - User performing the action
 */
export function setSetting(shopId, key, value, actorUserId) {
    const db = getDatabase();
    const stmt = db.prepare(`
    INSERT INTO settings (shop_id, key, value_json) VALUES (?, ?, ?)
    ON CONFLICT(shop_id, key) DO UPDATE SET value_json = excluded.value_json
  `);

    stmt.run(shopId, key, JSON.stringify(value));
    logAction(shopId, 'setting', key, 'UPDATE', { value }, actorUserId);
}

/**
 * Get all settings for a shop
 */
export function getAllSettings(shopId) {
    const db = getDatabase();
    const stmt = db.prepare('SELECT key, value_json FROM settings WHERE shop_id = ?');
    const rows = stmt.all(shopId);

    const settings = {};
    rows.forEach(row => {
        settings[row.key] = JSON.parse(row.value_json);
    });

    return settings;
}

/**
 * Delete a setting for a shop
 * @param {string} shopId - Shop UUID
 * @param {string} key - Setting key to delete
 * @param {string} actorUserId - User performing the action
 */
export function deleteSetting(shopId, key, actorUserId) {
    const db = getDatabase();
    const stmt = db.prepare('DELETE FROM settings WHERE shop_id = ? AND key = ?');
    stmt.run(shopId, key);
    logAction(shopId, 'setting', key, 'DELETE', null, actorUserId);
}
</file>

<file path="src/routes/invoices.js">
import express from 'express';
import {
    createInvoice,
    assembleInvoice,
    updateInvoice,
    listInvoices,
    deleteInvoice,
    addInvoicePhoto,
    deleteInvoicePhoto
} from '../services/invoiceService.js';
import { savePhoto, deletePhoto } from '../services/fileService.js';
import { validate, schemas } from '../middleware/validator.js';
import { authenticateToken, adminOnly } from '../middleware/auth.js';
import { injectShopScope } from '../middleware/shopScope.js';
import { upload } from '../utils/upload.js';

const router = express.Router();

// All routes require authentication and shop scope
router.use(authenticateToken);
router.use(injectShopScope);

/**
 * @swagger
 * /api/invoices:
 *   get:
 *     summary: List all invoices (headers only)
 *     tags: [Invoices]
 */
router.get('/', (req, res, next) => {
    try {
        const invoices = listInvoices(req.shopId);
        res.json(invoices);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/invoices/{id}:
 *   get:
 *     summary: Get fully assembled invoice aggregate
 *     tags: [Invoices]
 */
router.get('/:id', (req, res, next) => {
    try {
        const invoice = assembleInvoice(req.shopId, req.params.id);

        if (!invoice) {
            return res.status(404).json({
                error: 'Invoice not found',
                requestId: req.requestId
            });
        }

        res.json(invoice);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/invoices:
 *   post:
 *     summary: Create new invoice
 *     description: Supports X-Request-Id header for idempotency
 *     tags: [Invoices]
 */
router.post('/', validate(schemas.invoice), (req, res, next) => {
    try {
        const requestId = req.headers['x-request-id'] || null;
        const invoice = createInvoice(req.shopId, req.body, requestId, req.user.userId);

        res.status(201).json(invoice);
    } catch (error) {
        next(error);
    }
});

/**
 * PUT /api/invoices/:id
 * Update existing invoice (full replacement)
 */
router.put('/:id', validate(schemas.invoice), (req, res, next) => {
    try {
        const invoice = updateInvoice(req.shopId, req.params.id, req.body, req.user.userId);
        res.json(invoice);
    } catch (error) {
        next(error);
    }
});

/**
 * DELETE /api/invoices/:id
 * Soft delete invoice (ADMIN only)
 */
router.delete('/:id', adminOnly, (req, res, next) => {
    try {
        deleteInvoice(req.shopId, req.params.id, req.user.userId);
        res.status(204).send();
    } catch (error) {
        next(error);
    }
});

/**
 * POST /api/invoices/:id/photos
 * Upload invoice photo
 */
router.post('/:id/photos', upload.single('photo'), (req, res, next) => {
    try {
        if (!req.file) {
            return res.status(400).json({
                error: 'No photo file provided',
                requestId: req.requestId
            });
        }

        // File already on disk from multer, just get metadata
        const { filePath, checksum } = savePhoto(req.file.filename);
        const photo = addInvoicePhoto(req.shopId, req.params.id, filePath, checksum);

        res.status(201).json(photo);
    } catch (error) {
        // Handle multer errors (file too large, wrong type, etc.)
        if (error.code === 'LIMIT_FILE_SIZE') {
            return res.status(400).json({
                error: 'File too large. Maximum size is 5MB',
                requestId: req.requestId
            });
        }
        if (error.code === 'INVALID_FILE_TYPE') {
            return res.status(400).json({
                error: 'Only image files are allowed',
                requestId: req.requestId
            });
        }
        next(error);
    }
});

/**
 * DELETE /api/invoices/:invoiceId/photos/:photoId
 * Delete invoice photo (ADMIN only)
 */
router.delete('/:invoiceId/photos/:photoId', adminOnly, (req, res, next) => {
    try {
        const filePath = deleteInvoicePhoto(req.shopId, req.params.photoId);
        deletePhoto(filePath);

        res.status(204).send();
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="src/routes/products.js">
import express from 'express';
import {
    createProduct,
    getProduct,
    listProducts,
    updateProduct,
    deleteProduct,
    addProductImage,
    deleteProductImage
} from '../services/productService.js';
import { savePhoto, deletePhoto } from '../services/fileService.js';
import { validate, schemas } from '../middleware/validator.js';
import { authenticateToken, adminOnly } from '../middleware/auth.js';
import { injectShopScope } from '../middleware/shopScope.js';
import { upload } from '../utils/upload.js';

const router = express.Router();

// All routes require authentication and shop scope
router.use(authenticateToken);
router.use(injectShopScope);

/**
 * @swagger
 * /api/products:
 *   get:
 *     summary: List products with optional filters
 *     tags: [Products]
 */
router.get('/', (req, res, next) => {
    try {
        const filters = {
            type: req.query.type,
            categoryId: req.query.categoryId
        };

        const products = listProducts(req.shopId, filters);
        res.json(products);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/products/{id}:
 *   get:
 *     summary: Get product with images
 *     tags: [Products]
 */
router.get('/:id', (req, res, next) => {
    try {
        const product = getProduct(req.shopId, req.params.id);

        if (!product) {
            return res.status(404).json({
                error: 'Product not found',
                requestId: req.requestId
            });
        }

        res.json(product);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/products:
 *   post:
 *     summary: Create new product
 *     tags: [Products]
 */
router.post('/', validate(schemas.product), (req, res, next) => {
    try {
        const product = createProduct(req.shopId, req.body, req.user.userId);
        res.status(201).json(product);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/products/{id}:
 *   put:
 *     summary: Update product
 *     tags: [Products]
 */
router.put('/:id', validate(schemas.product), (req, res, next) => {
    try {
        const product = updateProduct(req.shopId, req.params.id, req.body, req.user.userId);
        res.json(product);
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/products/{id}:
 *   delete:
 *     summary: Soft delete product (ADMIN only)
 *     tags: [Products]
 */
router.delete('/:id', adminOnly, (req, res, next) => {
    try {
        deleteProduct(req.shopId, req.params.id, req.user.userId);
        res.status(204).send();
    } catch (error) {
        next(error);
    }
});

/**
 * @swagger
 * /api/products/{id}/images:
 *   post:
 *     summary: Upload product image
 *     tags: [Products]
 */
router.post('/:id/images', upload.single('image'), (req, res, next) => {
    try {
        if (!req.file) {
            return res.status(400).json({
                error: 'No image file provided',
                requestId: req.requestId
            });
        }

        // File already on disk from multer, just get metadata
        const { filePath, checksum } = savePhoto(req.file.filename);
        const image = addProductImage(req.shopId, req.params.id, filePath, checksum);

        res.status(201).json(image);
    } catch (error) {
        // Handle multer errors (file too large, wrong type, etc.)
        if (error.code === 'LIMIT_FILE_SIZE') {
            return res.status(400).json({
                error: 'File too large. Maximum size is 5MB',
                requestId: req.requestId
            });
        }
        if (error.code === 'INVALID_FILE_TYPE') {
            return res.status(400).json({
                error: 'Only image files are allowed',
                requestId: req.requestId
            });
        }
        next(error);
    }
});

/**
 * @swagger
 * /api/products/{productId}/images/{imageId}:
 *   delete:
 *     summary: Delete product image (ADMIN only)
 *     tags: [Products]
 */
router.delete('/:productId/images/:imageId', adminOnly, (req, res, next) => {
    try {
        const filePath = deleteProductImage(req.shopId, req.params.imageId);
        deletePhoto(filePath);

        res.status(204).send();
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="src/services/backupService.js">
/**
 * Backup Service
 * Creates SQLite database backups using better-sqlite3's backup method
 * Supports restore from backup with strict validation
 */

import { getDatabase, closeDatabase } from '../db/init.js';
import { existsSync, mkdirSync, readdirSync, statSync, createWriteStream, createReadStream, rmSync, copyFileSync, readFileSync } from 'fs';
import { mkdir, rm, readdir, copyFile } from 'fs/promises';
import { join, dirname, basename } from 'path';
import { fileURLToPath } from 'url';
import { createChildLogger } from '../utils/logger.js';
import archiver from 'archiver';
import unzipper from 'unzipper';
import { config } from '../config/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const backupLogger = createChildLogger('backup');
const BACKUP_DIR = join(__dirname, '../../storage/backups');
const BACKUP_RETENTION_COUNT = 2; // Keep only the last N backups

/**
 * Ensure backup directory exists
 */
function ensureBackupDir() {
    if (!existsSync(BACKUP_DIR)) {
        mkdirSync(BACKUP_DIR, { recursive: true });
        backupLogger.info({ path: BACKUP_DIR }, 'Created backup directory');
    }
}

/**
 * Clean up old backup files, keeping only the most recent N backups
 * Only cleans up ZIP backups (swipe_backup_*.zip), not DB backups or emergency backups
 */
function cleanupOldBackups() {
    try {
        const files = readdirSync(BACKUP_DIR)
            .filter(f => f.startsWith('swipe_backup_') && f.endsWith('.zip'))
            .map(filename => {
                const filePath = join(BACKUP_DIR, filename);
                const stats = statSync(filePath);
                return { filename, filePath, mtime: stats.mtime };
            })
            .sort((a, b) => b.mtime - a.mtime); // Newest first

        if (files.length > BACKUP_RETENTION_COUNT) {
            const toDelete = files.slice(BACKUP_RETENTION_COUNT);
            for (const file of toDelete) {
                rmSync(file.filePath, { force: true });
                backupLogger.info({ deleted: file.filename }, 'Deleted old backup (retention policy)');
            }
            backupLogger.info({
                kept: BACKUP_RETENTION_COUNT,
                deleted: toDelete.length
            }, 'Backup cleanup completed');
        }
    } catch (error) {
        // Don't fail the backup if cleanup fails
        backupLogger.warn({ err: error }, 'Backup cleanup failed (non-fatal)');
    }
}

/**
 * Create a database backup
 * @returns {Object} Backup metadata (path, timestamp, size)
 */
export function createBackup() {
    ensureBackupDir();

    const db = getDatabase();
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `swipe_${timestamp}.db`;
    const backupPath = join(BACKUP_DIR, filename);

    backupLogger.info({ backupPath }, 'Starting database backup');

    // Use better-sqlite3's backup method (synchronous, safe)
    db.backup(backupPath)
        .then(() => {
            backupLogger.info({ backupPath }, 'Backup completed successfully');
        })
        .catch((err) => {
            backupLogger.error({ err, backupPath }, 'Backup failed');
            throw err;
        });

    // Get file size after backup
    const stats = statSync(backupPath);

    return {
        path: backupPath,
        filename,
        timestamp: new Date().toISOString(),
        sizeBytes: stats.size
    };
}

/**
 * List existing backups
 * @returns {Array} List of backup metadata
 */
export function listBackups() {
    ensureBackupDir();

    const files = readdirSync(BACKUP_DIR)
        .filter(f => f.endsWith('.db'))
        .map(filename => {
            const filePath = join(BACKUP_DIR, filename);
            const stats = statSync(filePath);
            return {
                filename,
                path: filePath,
                createdAt: stats.mtime.toISOString(),
                sizeBytes: stats.size
            };
        })
        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

    return files;
}

/**
 * In-memory mutex flags to prevent concurrent operations
 */
let isBackupRunning = false;
let isRestoreRunning = false;

/**
 * Validate backup filename to prevent path traversal attacks
 * @param {string} filename - Filename to validate
 * @returns {boolean} True if valid, false otherwise
 */
export function validateBackupFilename(filename) {
    // Must be a ZIP file
    if (!filename.endsWith('.zip')) return false;

    // Must match the expected pattern: swipe_backup_<timestamp>.zip
    const pattern = /^swipe_backup_[\d-TZ]+\.zip$/;
    if (!pattern.test(filename)) return false;

    // No path traversal characters
    if (filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
        return false;
    }

    return true;
}

/**
 * Get the full path for a backup file (safely)
 * @param {string} filename - Validated backup filename
 * @returns {string} Full path to backup file
 */
export function getBackupPath(filename) {
    return join(BACKUP_DIR, filename);
}

/**
 * Create a full backup (SQLite DB + file storage) as a ZIP file
 * @returns {Promise<Object>} Backup metadata (filename, sizeBytes, createdAt)
 */
export async function createFullBackup() {
    // Check mutex - prevent concurrent backups
    if (isBackupRunning) {
        const error = new Error('Backup already in progress');
        error.statusCode = 409;
        throw error;
    }

    ensureBackupDir();

    try {
        // Set mutex flag
        isBackupRunning = true;

        const db = getDatabase();
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const tempDbFilename = `swipe_temp_${timestamp}.db`;
        const zipFilename = `swipe_backup_${timestamp}.zip`;
        const tempDbPath = join(BACKUP_DIR, tempDbFilename);
        const zipPath = join(BACKUP_DIR, zipFilename);

        backupLogger.info({ zipPath }, 'Starting full backup (DB + storage)');

        // Step 1: Create WAL-safe SQLite backup using better-sqlite3's backup method
        backupLogger.info({ tempDbPath }, 'Creating SQLite backup');
        await db.backup(tempDbPath);
        backupLogger.info('SQLite backup completed');

        // Step 2: Create ZIP archive with streaming
        backupLogger.info({ zipPath }, 'Creating ZIP archive');

        const output = createWriteStream(zipPath);
        const archive = archiver('zip', {
            zlib: { level: 6 } // Balanced compression
        });

        // Promise to handle ZIP creation
        const zipPromise = new Promise((resolve, reject) => {
            output.on('close', () => {
                backupLogger.info({
                    zipPath,
                    totalBytes: archive.pointer()
                }, 'ZIP archive created successfully');
                resolve();
            });

            archive.on('error', (err) => {
                backupLogger.error({ err, zipPath }, 'ZIP archive creation failed');
                reject(err);
            });

            archive.on('warning', (err) => {
                if (err.code === 'ENOENT') {
                    backupLogger.warn({ err }, 'ZIP archive warning');
                } else {
                    reject(err);
                }
            });
        });

        // Pipe archive to output file
        archive.pipe(output);

        // Add the SQLite database backup to ZIP
        archive.file(tempDbPath, { name: 'swipe.db' });

        // Add storage directory (photos) to ZIP
        const storagePath = config.storagePath;
        if (existsSync(storagePath)) {
            backupLogger.info({ storagePath }, 'Adding storage directory to ZIP');
            archive.directory(storagePath, 'storage/photos');
        } else {
            backupLogger.warn({ storagePath }, 'Storage directory does not exist, skipping');
        }

        // Finalize the archive
        await archive.finalize();

        // Wait for ZIP to complete
        await zipPromise;

        // Get final ZIP file size
        const stats = statSync(zipPath);

        // Clean up temporary DB file
        const fs = await import('fs/promises');
        await fs.unlink(tempDbPath);
        backupLogger.info({ tempDbPath }, 'Cleaned up temporary DB file');

        const metadata = {
            filename: zipFilename,
            sizeBytes: stats.size,
            createdAt: new Date().toISOString()
        };

        backupLogger.info(metadata, 'Full backup completed successfully');

        // Clean up old backups (retention policy)
        cleanupOldBackups();

        return metadata;

    } catch (error) {
        backupLogger.error({ err: error }, 'Full backup failed');
        throw error;
    } finally {
        // Always reset mutex flag
        isBackupRunning = false;
    }
}

/**
 * SQLite file signature (first 16 bytes)
 */
const SQLITE_HEADER = Buffer.from('SQLite format 3\0');

/**
 * Validate that a file is a valid SQLite database
 * @param {string} filePath - Path to the database file
 * @returns {boolean} True if valid SQLite file
 */
function validateSQLiteFile(filePath) {
    try {
        const header = readFileSync(filePath, { encoding: null }).slice(0, 16);
        return header.equals(SQLITE_HEADER);
    } catch {
        return false;
    }
}

/**
 * Validate a ZIP entry path for security
 * @param {string} entryPath - Path from ZIP entry
 * @returns {boolean} True if path is safe
 */
function isPathSafe(entryPath) {
    // Reject absolute paths
    if (entryPath.startsWith('/') || entryPath.startsWith('\\')) {
        return false;
    }
    // Reject path traversal
    if (entryPath.includes('..')) {
        return false;
    }
    // Reject backslash (Windows path separator could be sneaky)
    if (entryPath.includes('\\')) {
        return false;
    }
    return true;
}

/**
 * Restore from a backup ZIP file
 * WARNING: This will replace all current data and terminate the process
 * 
 * @param {string} zipPath - Path to the uploaded ZIP file
 * @param {Object} auditContext - Context for audit logging { shopId, userId }
 * @returns {Promise<Object>} Restore metadata
 */
export async function restoreFromBackup(zipPath, auditContext) {
    // Check mutex - prevent concurrent restores
    if (isRestoreRunning) {
        const error = new Error('Restore already in progress');
        error.statusCode = 409;
        throw error;
    }

    // Also prevent restore while backup is running
    if (isBackupRunning) {
        const error = new Error('Cannot restore while backup is in progress');
        error.statusCode = 409;
        throw error;
    }

    ensureBackupDir();

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const tempDir = join(BACKUP_DIR, `restore_temp_${timestamp}`);

    try {
        isRestoreRunning = true;

        backupLogger.info({ zipPath }, 'Starting restore from backup');

        // Step 1: Create temp extraction directory
        await mkdir(tempDir, { recursive: true });
        backupLogger.info({ tempDir }, 'Created temp extraction directory');

        // Step 2: Extract and validate ZIP contents
        let hasSwipeDb = false;
        let hasStorageDir = false;
        const extractedPhotos = [];

        await new Promise((resolve, reject) => {
            createReadStream(zipPath)
                .pipe(unzipper.Parse())
                .on('entry', async (entry) => {
                    const entryPath = entry.path;
                    const type = entry.type; // 'Directory' or 'File'

                    // Security: Validate path
                    if (!isPathSafe(entryPath)) {
                        backupLogger.error({ entryPath }, 'Unsafe path in ZIP, aborting');
                        entry.autodrain();
                        reject(new Error(`Unsafe path in backup: ${entryPath}`));
                        return;
                    }

                    // Check for swipe.db at root
                    if (entryPath === 'swipe.db' && type === 'File') {
                        hasSwipeDb = true;
                        const destPath = join(tempDir, 'swipe.db');
                        entry.pipe(createWriteStream(destPath));
                        backupLogger.info('Found swipe.db in backup');
                    }
                    // Check for storage/photos/ directory
                    else if (entryPath.startsWith('storage/photos/') && type === 'File') {
                        hasStorageDir = true;
                        // Extract relative to storage/photos/
                        const relativePath = entryPath.replace('storage/photos/', '');
                        if (relativePath && !relativePath.includes('/')) {
                            // Only extract files directly in photos dir (not nested subdirs)
                            const photosDir = join(tempDir, 'photos');
                            if (!existsSync(photosDir)) {
                                mkdirSync(photosDir, { recursive: true });
                            }
                            const destPath = join(photosDir, relativePath);
                            entry.pipe(createWriteStream(destPath));
                            extractedPhotos.push(relativePath);
                        } else if (relativePath.includes('/')) {
                            // Handle nested paths like storage/photos/uploads/file.jpg
                            const photosDir = join(tempDir, 'photos');
                            const fullPath = join(photosDir, relativePath);
                            const dir = dirname(fullPath);
                            if (!existsSync(dir)) {
                                mkdirSync(dir, { recursive: true });
                            }
                            entry.pipe(createWriteStream(fullPath));
                            extractedPhotos.push(relativePath);
                        } else {
                            entry.autodrain();
                        }
                    }
                    else {
                        entry.autodrain();
                    }
                })
                .on('close', resolve)
                .on('error', reject);
        });

        // Step 3: Validate extracted contents
        if (!hasSwipeDb) {
            const error = new Error('Invalid backup: swipe.db not found at root');
            error.statusCode = 400;
            throw error;
        }

        const extractedDbPath = join(tempDir, 'swipe.db');
        if (!validateSQLiteFile(extractedDbPath)) {
            const error = new Error('Invalid backup: swipe.db is not a valid SQLite database');
            error.statusCode = 400;
            throw error;
        }

        backupLogger.info({
            hasSwipeDb,
            hasStorageDir,
            extractedPhotos: extractedPhotos.length
        }, 'Backup validation passed');

        // Step 4: Create emergency backup of current state
        const emergencyBackupPath = join(BACKUP_DIR, `emergency_pre_restore_${timestamp}.db`);
        const currentDbPath = config.databasePath;

        backupLogger.info({ emergencyBackupPath }, 'Creating emergency backup before restore');

        // Close current database connection
        closeDatabase();

        // Copy current DB to emergency backup
        copyFileSync(currentDbPath, emergencyBackupPath);
        backupLogger.info({ emergencyBackupPath }, 'Emergency backup created');

        // Step 5: Replace swipe.db
        backupLogger.info('Replacing database file');
        copyFileSync(extractedDbPath, currentDbPath);
        backupLogger.info('Database replaced');

        // Step 6: Replace storage/photos/ if present in backup
        const currentPhotosPath = config.storagePath;
        const extractedPhotosPath = join(tempDir, 'photos');

        if (existsSync(extractedPhotosPath)) {
            backupLogger.info({ currentPhotosPath }, 'Replacing photos directory');

            // Remove current photos
            if (existsSync(currentPhotosPath)) {
                rmSync(currentPhotosPath, { recursive: true, force: true });
            }

            // Copy extracted photos
            await copyDirRecursive(extractedPhotosPath, currentPhotosPath);
            backupLogger.info({ photosRestored: extractedPhotos.length }, 'Photos restored');
        }

        // Step 7: Clean up temp directory
        await rm(tempDir, { recursive: true, force: true });
        backupLogger.info({ tempDir }, 'Cleaned up temp directory');

        // Step 8: Log audit event (to file since DB is being replaced)
        backupLogger.info({
            action: 'SYSTEM_RESTORE',
            shopId: auditContext?.shopId,
            userId: auditContext?.userId,
            photosRestored: extractedPhotos.length,
            emergencyBackupPath
        }, 'SYSTEM_RESTORE completed');

        const metadata = {
            success: true,
            restartRequired: true,
            photosRestored: extractedPhotos.length,
            emergencyBackupPath: basename(emergencyBackupPath),
            restoredAt: new Date().toISOString()
        };

        backupLogger.info(metadata, 'Restore completed successfully. Server will exit.');

        // Return metadata before exit (response will be sent by route handler)
        // The route handler will call process.exit(0) after sending response
        return metadata;

    } catch (error) {
        backupLogger.error({ err: error }, 'Restore failed');

        // Clean up temp directory on error
        if (existsSync(tempDir)) {
            try {
                await rm(tempDir, { recursive: true, force: true });
            } catch (cleanupErr) {
                backupLogger.error({ cleanupErr }, 'Failed to clean up temp directory');
            }
        }

        throw error;
    } finally {
        isRestoreRunning = false;
    }
}

/**
 * Recursively copy a directory
 * @param {string} src - Source directory
 * @param {string} dest - Destination directory
 */
async function copyDirRecursive(src, dest) {
    await mkdir(dest, { recursive: true });
    const entries = await readdir(src, { withFileTypes: true });

    for (const entry of entries) {
        const srcPath = join(src, entry.name);
        const destPath = join(dest, entry.name);

        if (entry.isDirectory()) {
            await copyDirRecursive(srcPath, destPath);
        } else {
            await copyFile(srcPath, destPath);
        }
    }
}
</file>

<file path="src/services/categoryService.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase } from '../db/init.js';
import { generateUUID } from '../utils/uuid.js';
import { logAction } from './auditService.js';
import { sanitizeString } from '../utils/sanitize.js';

/**
 * Create a new category
 * @param {string} shopId - Shop UUID
 * @param {Object} data - Category data
 * @param {string} actorUserId - User performing the action
 */
export function createCategory(shopId, data, actorUserId) {
    const db = getDatabase();
    const categoryId = generateUUID();

    // Sanitize name to prevent XSS
    const sanitizedName = sanitizeString(data.name);

    db.prepare(`
    INSERT INTO categories (id, shop_id, name, type) VALUES (?, ?, ?, ?)
  `).run(categoryId, shopId, sanitizedName, data.type);

    logAction(shopId, 'category', categoryId, 'CREATE', { name: sanitizedName }, actorUserId);

    return getCategory(shopId, categoryId);
}

/**
 * Get a single category with subcategories
 */
export function getCategory(shopId, categoryId) {
    const db = getDatabase();

    const category = db.prepare('SELECT * FROM categories WHERE id = ? AND shop_id = ?').get(categoryId, shopId);
    if (!category) return null;

    const subcategories = db.prepare(
        'SELECT * FROM subcategories WHERE category_id = ?'
    ).all(categoryId);

    return { ...category, subcategories };
}

/**
 * List all categories with subcategories
 */
export function listCategories(shopId) {
    const db = getDatabase();
    const categories = db.prepare('SELECT * FROM categories WHERE shop_id = ? ORDER BY name').all(shopId);

    return categories.map(cat => ({
        ...cat,
        subcategories: db.prepare(
            'SELECT * FROM subcategories WHERE category_id = ? ORDER BY name'
        ).all(cat.id)
    }));
}

/**
 * Update a category
 * @param {string} shopId - Shop UUID
 * @param {string} categoryId - Category UUID
 * @param {Object} data - Update data
 * @param {string} actorUserId - User performing the action
 */
export function updateCategory(shopId, categoryId, data, actorUserId) {
    const db = getDatabase();

    // Sanitize name to prevent XSS
    const sanitizedName = sanitizeString(data.name);

    const result = db.prepare(
        'UPDATE categories SET name = ?, type = ? WHERE id = ? AND shop_id = ?'
    ).run(sanitizedName, data.type, categoryId, shopId);

    if (result.changes === 0) throw new Error('Category not found');
    logAction(shopId, 'category', categoryId, 'UPDATE', null, actorUserId);
    return getCategory(shopId, categoryId);
}

/**
 * Delete a category
 * @param {string} shopId - Shop UUID
 * @param {string} categoryId - Category UUID
 * @param {string} actorUserId - User performing the action
 */
export function deleteCategory(shopId, categoryId, actorUserId) {
    const db = getDatabase();

    const category = db.prepare('SELECT id FROM categories WHERE id = ? AND shop_id = ?').get(categoryId, shopId);
    if (!category) throw new Error('Category not found');

    db.prepare('DELETE FROM subcategories WHERE category_id = ?').run(categoryId);
    db.prepare('DELETE FROM categories WHERE id = ?').run(categoryId);
    logAction(shopId, 'category', categoryId, 'DELETE', null, actorUserId);
}

/**
 * Create a subcategory
 * @param {string} shopId - Shop UUID (for validation)
 * @param {string} categoryId - Category UUID
 * @param {Object} data - Subcategory data
 * @param {string} actorUserId - User performing the action
 */
export function createSubcategory(shopId, categoryId, data, actorUserId) {
    const db = getDatabase();

    const category = db.prepare('SELECT id FROM categories WHERE id = ? AND shop_id = ?').get(categoryId, shopId);
    if (!category) throw new Error('Category not found');

    const subcategoryId = generateUUID();

    // Sanitize name to prevent XSS
    const sanitizedName = sanitizeString(data.name);

    db.prepare(`
    INSERT INTO subcategories (id, category_id, name) VALUES (?, ?, ?)
  `).run(subcategoryId, categoryId, sanitizedName);

    logAction(shopId, 'subcategory', subcategoryId, 'CREATE', { name: sanitizedName }, actorUserId);

    return { id: subcategoryId, category_id: categoryId, name: sanitizedName };
}

/**
 * Delete a subcategory
 * @param {string} shopId - Shop UUID (for validation)
 * @param {string} subcategoryId - Subcategory UUID
 * @param {string} actorUserId - User performing the action
 */
export function deleteSubcategory(shopId, subcategoryId, actorUserId) {
    const db = getDatabase();

    const subcategory = db.prepare(`
        SELECT sc.id FROM subcategories sc
        JOIN categories c ON sc.category_id = c.id
        WHERE sc.id = ? AND c.shop_id = ?
    `).get(subcategoryId, shopId);

    if (!subcategory) throw new Error('Subcategory not found');

    db.prepare('DELETE FROM subcategories WHERE id = ?').run(subcategoryId);
    logAction(shopId, 'subcategory', subcategoryId, 'DELETE', null, actorUserId);
}
</file>

<file path="src/services/customerService.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase } from '../db/init.js';
import { generateUUID } from '../utils/uuid.js';
import { recalculateBalance, toRupees } from '../utils/calculator.js';
import { logAction } from './auditService.js';
import { sanitizeString } from '../utils/sanitize.js';

/**
 * Create a new customer
 * @param {string} shopId - Shop UUID
 * @param {Object} data - Customer data
 * @param {string} actorUserId - User performing the action
 */
export function createCustomer(shopId, data, actorUserId) {
  const db = getDatabase();
  const customerId = generateUUID();
  const now = new Date().toISOString();

  // Sanitize user input to prevent XSS
  const sanitizedName = sanitizeString(data.name);
  const sanitizedAddress = typeof data.address === 'string'
    ? sanitizeString(data.address)
    : data.address;

  db.prepare(`
    INSERT INTO customers (
      id, shop_id, name, gstin, phone, email, balance, balance_paisa, address_json, created_at, updated_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(
    customerId,
    shopId,
    sanitizedName,
    data.gstin || null,
    data.phone || null,
    data.email || null,
    0, // Initial balance
    0, // Initial balance_paisa
    sanitizedAddress ? JSON.stringify(sanitizedAddress) : null,
    now,
    now
  );

  logAction(shopId, 'customer', customerId, 'CREATE', { name: sanitizedName }, actorUserId);

  return getCustomer(shopId, customerId);
}

/**
 * Get a single customer
 * @param {string} shopId - Shop UUID
 * @param {string} customerId - Customer UUID
 */
export function getCustomer(shopId, customerId) {
  const db = getDatabase();

  const customer = db.prepare(`
    SELECT * FROM customers WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
  `).get(customerId, shopId);

  if (!customer) return null;

  return {
    ...customer,
    balance: toRupees(customer.balance_paisa || 0), // Serialize to decimal
    address: customer.address_json ? JSON.parse(customer.address_json) : null
  };
}

/**
 * List all customers for a shop
 * @param {string} shopId - Shop UUID
 */
export function listCustomers(shopId) {
  const db = getDatabase();

  const customers = db.prepare(`
    SELECT * FROM customers WHERE shop_id = ? AND deleted_at IS NULL ORDER BY name
  `).all(shopId);

  return customers.map(c => ({
    ...c,
    balance: toRupees(c.balance_paisa || 0), // Serialize to decimal
    address: c.address_json ? JSON.parse(c.address_json) : null
  }));
}

/**
 * Update a customer
 * @param {string} shopId - Shop UUID
 * @param {string} customerId - Customer UUID
 * @param {Object} data - Update data
 * @param {string} actorUserId - User performing the action
 */
export function updateCustomer(shopId, customerId, data, actorUserId) {
  const db = getDatabase();
  const now = new Date().toISOString();

  // Sanitize user input to prevent XSS
  const sanitizedName = sanitizeString(data.name);
  const sanitizedAddress = typeof data.address === 'string'
    ? sanitizeString(data.address)
    : data.address;

  const result = db.prepare(`
    UPDATE customers
    SET name = ?, gstin = ?, phone = ?, email = ?, address_json = ?, updated_at = ?
    WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
  `).run(
    sanitizedName,
    data.gstin || null,
    data.phone || null,
    data.email || null,
    sanitizedAddress ? JSON.stringify(sanitizedAddress) : null,
    now,
    customerId,
    shopId
  );

  if (result.changes === 0) {
    throw new Error('Customer not found');
  }

  logAction(shopId, 'customer', customerId, 'UPDATE', null, actorUserId);

  return getCustomer(shopId, customerId);
}

/**
 * Soft delete a customer
 * @param {string} shopId - Shop UUID
 * @param {string} customerId - Customer UUID
 * @param {string} actorUserId - User performing the action
 */
export function deleteCustomer(shopId, customerId, actorUserId) {
  const db = getDatabase();

  const result = db.prepare(`
    UPDATE customers SET deleted_at = ? WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
  `).run(new Date().toISOString(), customerId, shopId);

  if (result.changes === 0) {
    throw new Error('Customer not found or already deleted');
  }

  logAction(shopId, 'customer', customerId, 'DELETE', null, actorUserId);
}

/**
 * Update customer balance (derived from invoices and payments)
 * @param {string} shopId - Shop UUID
 * @param {string} customerId - Customer UUID
 */
export function updateCustomerBalance(shopId, customerId) {
  const db = getDatabase();

  const balancePaisa = recalculateBalance(db, customerId, 'CUSTOMER');

  db.prepare(`
    UPDATE customers SET balance_paisa = ?, balance = ? WHERE id = ? AND shop_id = ?
  `).run(balancePaisa, toRupees(balancePaisa), customerId, shopId);

  return balancePaisa;
}
</file>

<file path="src/services/purchaseService.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase, transaction } from '../db/init.js';
import { generateUUID } from '../utils/uuid.js';
import { generatePurchaseNumber } from './sequenceService.js';
import { logAction } from './auditService.js';
import { bustHomeCache } from '../routes/home.js';

/**
 * Create a new purchase
 * @param {string} shopId - Shop UUID
 * @param {Object} data - Purchase data
 * @param {string} actorUserId - User performing the action
 */
export function createPurchase(shopId, data, actorUserId) {
    return transaction((db) => {
        const purchaseId = generateUUID();
        const purchaseNumber = generatePurchaseNumber(shopId);
        const now = new Date().toISOString();

        db.prepare(`
      INSERT INTO purchases (id, shop_id, purchase_number, vendor_id, status, date, due_date, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
            purchaseId, shopId, purchaseNumber,
            data.vendorId || null, data.status || 'UNPAID',
            data.date, data.dueDate || null, now, now
        );

        logAction(shopId, 'purchase', purchaseId, 'CREATE', { purchaseNumber }, actorUserId);
        bustHomeCache(shopId);
        return getPurchase(shopId, purchaseId);
    });
}

/**
 * Get a single purchase
 */
export function getPurchase(shopId, purchaseId) {
    const db = getDatabase();
    const purchase = db.prepare(
        'SELECT * FROM purchases WHERE id = ? AND shop_id = ? AND deleted_at IS NULL'
    ).get(purchaseId, shopId);

    if (!purchase) return null;

    let vendor = null;
    if (purchase.vendor_id) {
        vendor = db.prepare('SELECT id, name, phone FROM vendors WHERE id = ? AND shop_id = ?').get(purchase.vendor_id, shopId);
    }

    return { ...purchase, vendor };
}

/**
 * List all purchases for a shop
 */
export function listPurchases(shopId, filters = {}) {
    const db = getDatabase();
    let query = 'SELECT * FROM purchases WHERE shop_id = ? AND deleted_at IS NULL';
    const params = [shopId];

    if (filters.vendorId) {
        query += ' AND vendor_id = ?';
        params.push(filters.vendorId);
    }

    if (filters.status) {
        query += ' AND status = ?';
        params.push(filters.status);
    }

    query += ' ORDER BY date DESC, created_at DESC';
    return db.prepare(query).all(...params);
}

/**
 * Update a purchase
 * @param {string} shopId - Shop UUID
 * @param {string} purchaseId - Purchase UUID
 * @param {Object} data - Update data
 * @param {string} actorUserId - User performing the action
 */
export function updatePurchase(shopId, purchaseId, data, actorUserId) {
    const db = getDatabase();
    const now = new Date().toISOString();

    const result = db.prepare(`
    UPDATE purchases SET vendor_id = ?, status = ?, date = ?, due_date = ?, updated_at = ?
    WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
  `).run(data.vendorId || null, data.status, data.date, data.dueDate || null, now, purchaseId, shopId);

    if (result.changes === 0) throw new Error('Purchase not found');
    logAction(shopId, 'purchase', purchaseId, 'UPDATE', null, actorUserId);
    bustHomeCache(shopId);
    return getPurchase(shopId, purchaseId);
}

/**
 * Soft delete a purchase
 * @param {string} shopId - Shop UUID
 * @param {string} purchaseId - Purchase UUID
 * @param {string} actorUserId - User performing the action
 */
export function deletePurchase(shopId, purchaseId, actorUserId) {
    const db = getDatabase();
    const result = db.prepare(
        'UPDATE purchases SET deleted_at = ? WHERE id = ? AND shop_id = ? AND deleted_at IS NULL'
    ).run(new Date().toISOString(), purchaseId, shopId);

    if (result.changes === 0) throw new Error('Purchase not found');
    logAction(shopId, 'purchase', purchaseId, 'DELETE', null, actorUserId);
    bustHomeCache(shopId);
}
</file>

<file path="src/services/vendorService.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase } from '../db/init.js';
import { generateUUID } from '../utils/uuid.js';
import { recalculateBalance, toRupees } from '../utils/calculator.js';
import { logAction } from './auditService.js';
import { sanitizeString } from '../utils/sanitize.js';

/**
 * Create a new vendor
 * @param {string} shopId - Shop UUID
 * @param {Object} data - Vendor data
 * @param {string} actorUserId - User performing the action
 */
export function createVendor(shopId, data, actorUserId) {
  const db = getDatabase();
  const vendorId = generateUUID();
  const now = new Date().toISOString();

  // Sanitize user input to prevent XSS
  const sanitizedName = sanitizeString(data.name);
  const sanitizedAddress = typeof data.address === 'string'
    ? sanitizeString(data.address)
    : data.address;

  db.prepare(`
    INSERT INTO vendors (id, shop_id, name, gstin, phone, email, balance, balance_paisa, address_json, created_at, updated_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(
    vendorId,
    shopId,
    sanitizedName,
    data.gstin || null,
    data.phone || null,
    data.email || null,
    0, // Initial balance
    0, // Initial balance_paisa
    sanitizedAddress ? JSON.stringify(sanitizedAddress) : null,
    now,
    now
  );

  logAction(shopId, 'vendor', vendorId, 'CREATE', { name: sanitizedName }, actorUserId);

  return getVendor(shopId, vendorId);
}

/**
 * Get a single vendor
 * @param {string} shopId - Shop UUID
 * @param {string} vendorId - Vendor UUID
 */
export function getVendor(shopId, vendorId) {
  const db = getDatabase();
  const vendor = db.prepare(`
    SELECT * FROM vendors WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
  `).get(vendorId, shopId);

  if (!vendor) return null;

  return {
    ...vendor,
    balance: toRupees(vendor.balance_paisa || 0), // Serialize to decimal
    address: vendor.address_json ? JSON.parse(vendor.address_json) : null
  };
}

/**
 * List all vendors for a shop
 * @param {string} shopId - Shop UUID
 */
export function listVendors(shopId) {
  const db = getDatabase();
  const vendors = db.prepare(`
    SELECT * FROM vendors WHERE shop_id = ? AND deleted_at IS NULL ORDER BY name
  `).all(shopId);

  return vendors.map(v => ({
    ...v,
    balance: toRupees(v.balance_paisa || 0), // Serialize to decimal
    address: v.address_json ? JSON.parse(v.address_json) : null
  }));
}

/**
 * Update a vendor
 * @param {string} shopId - Shop UUID
 * @param {string} vendorId - Vendor UUID
 * @param {Object} data - Update data
 * @param {string} actorUserId - User performing the action
 */
export function updateVendor(shopId, vendorId, data, actorUserId) {
  const db = getDatabase();
  const now = new Date().toISOString();

  // Sanitize user input to prevent XSS
  const sanitizedName = sanitizeString(data.name);
  const sanitizedAddress = typeof data.address === 'string'
    ? sanitizeString(data.address)
    : data.address;

  const result = db.prepare(`
    UPDATE vendors
    SET name = ?, gstin = ?, phone = ?, email = ?, address_json = ?, updated_at = ?
    WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
  `).run(
    sanitizedName,
    data.gstin || null,
    data.phone || null,
    data.email || null,
    sanitizedAddress ? JSON.stringify(sanitizedAddress) : null,
    now,
    vendorId,
    shopId
  );

  if (result.changes === 0) throw new Error('Vendor not found');

  logAction(shopId, 'vendor', vendorId, 'UPDATE', null, actorUserId);

  return getVendor(shopId, vendorId);
}

/**
 * Soft delete a vendor
 * @param {string} shopId - Shop UUID
 * @param {string} vendorId - Vendor UUID
 * @param {string} actorUserId - User performing the action
 */
export function deleteVendor(shopId, vendorId, actorUserId) {
  const db = getDatabase();
  const result = db.prepare(`
    UPDATE vendors SET deleted_at = ? WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
  `).run(new Date().toISOString(), vendorId, shopId);

  if (result.changes === 0) throw new Error('Vendor not found or already deleted');

  logAction(shopId, 'vendor', vendorId, 'DELETE', null, actorUserId);
}

/**
 * Update vendor balance (derived from purchases and payments)
 * @param {string} shopId - Shop UUID
 * @param {string} vendorId - Vendor UUID
 */
export function updateVendorBalance(shopId, vendorId) {
  const db = getDatabase();

  const balancePaisa = recalculateBalance(db, vendorId, 'VENDOR');

  db.prepare(`
    UPDATE vendors SET balance_paisa = ?, balance = ? WHERE id = ? AND shop_id = ?
  `).run(balancePaisa, toRupees(balancePaisa), vendorId, shopId);

  return balancePaisa;
}
</file>

<file path="src/services/invoiceService.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase, transaction } from '../db/init.js';
import { generateUUID } from '../utils/uuid.js';
import { generateInvoiceNumber } from './sequenceService.js';
import { calculateInvoiceTotals, toRupees } from '../utils/calculator.js';
import { assembleInvoiceAggregate, decomposeInvoiceAggregate } from '../models/InvoiceAggregate.js';
import { logAction } from './auditService.js';
import { bustHomeCache } from '../routes/home.js';
import { sanitizeString } from '../utils/sanitize.js';

/**
 * Assemble a complete invoice aggregate from database
 * READ operation - joins data from 5 tables
 */
export function assembleInvoice(shopId, invoiceId) {
  const db = getDatabase();

  const invoice = db.prepare(`
    SELECT * FROM invoices WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
  `).get(invoiceId, shopId);

  if (!invoice) return null;

  const customer = db.prepare(`
    SELECT * FROM invoice_customer_snapshot WHERE invoice_id = ?
  `).get(invoiceId);

  const items = db.prepare(`
    SELECT * FROM invoice_items WHERE invoice_id = ?
  `).all(invoiceId);

  const totals = db.prepare(`
    SELECT * FROM invoice_totals WHERE invoice_id = ?
  `).get(invoiceId);

  const photos = db.prepare(`
    SELECT * FROM invoice_photos WHERE invoice_id = ?
  `).all(invoiceId);

  return assembleInvoiceAggregate(invoice, customer, items, totals, photos);
}

/**
 * Create a new invoice (TRANSACTIONAL)
 * @param {string} shopId - Shop UUID
 * @param {Object} aggregatePayload - Invoice aggregate from client
 * @param {string} requestId - Optional idempotency key
 * @param {string} actorUserId - User performing the action
 */
export function createInvoice(shopId, aggregatePayload, requestId = null, actorUserId) {
  return transaction((db) => {
    const now = new Date().toISOString();

    if (requestId) {
      const existing = db.prepare(`
        SELECT entity_id FROM idempotency_keys WHERE request_id = ? AND shop_id = ?
      `).get(requestId, shopId);

      if (existing) {
        return assembleInvoice(shopId, existing.entity_id);
      }
    }

    const invoiceId = generateUUID();
    const invoiceNumber = generateInvoiceNumber(shopId);

    const computedTotals = calculateInvoiceTotals(
      aggregatePayload.items,
      aggregatePayload.placeOfSupply
    );

    const decomposed = decomposeInvoiceAggregate(aggregatePayload, {
      totals: computedTotals
    });

    // Sanitize customer snapshot fields to prevent XSS
    const sanitizedCustomerName = sanitizeString(decomposed.customerSnapshot.name);
    const sanitizedCustomerAddress = decomposed.customerSnapshot.address_json;

    // Sanitize item descriptions
    const sanitizedItems = decomposed.items.map(item => ({
      ...item,
      description: sanitizeString(item.description)
    }));

    db.prepare(`
      INSERT INTO invoices (
        id, shop_id, invoice_number, customer_id, type, status, date, due_date, 
        place_of_supply, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      invoiceId, shopId, invoiceNumber,
      decomposed.invoice.customer_id, decomposed.invoice.type,
      decomposed.invoice.status, decomposed.invoice.date,
      decomposed.invoice.due_date, decomposed.invoice.place_of_supply,
      now, now
    );

    db.prepare(`
      INSERT INTO invoice_customer_snapshot (invoice_id, name, phone, gstin, address_json)
      VALUES (?, ?, ?, ?, ?)
    `).run(invoiceId, sanitizedCustomerName, decomposed.customerSnapshot.phone,
      decomposed.customerSnapshot.gstin, sanitizedCustomerAddress);

    const itemStmt = db.prepare(`
      INSERT INTO invoice_items (id, invoice_id, product_id, description, quantity, rate, tax_rate, weight_json, amount_json)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    sanitizedItems.forEach(item => {
      itemStmt.run(generateUUID(), invoiceId, item.product_id, item.description,
        item.quantity, item.rate, item.tax_rate, item.weight_json, item.amount_json);
    });

    db.prepare(`
      INSERT INTO invoice_totals (
        invoice_id,
        subtotal_paisa, tax_total_paisa, cgst_paisa, sgst_paisa, igst_paisa, round_off_paisa, grand_total_paisa,
        subtotal, tax_total, cgst, sgst, igst, round_off, grand_total
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      invoiceId,
      computedTotals.subtotalPaisa, computedTotals.taxTotalPaisa,
      computedTotals.cgstPaisa, computedTotals.sgstPaisa, computedTotals.igstPaisa,
      computedTotals.roundOffPaisa, computedTotals.grandTotalPaisa,
      toRupees(computedTotals.subtotalPaisa), toRupees(computedTotals.taxTotalPaisa),
      toRupees(computedTotals.cgstPaisa), toRupees(computedTotals.sgstPaisa),
      toRupees(computedTotals.igstPaisa), toRupees(computedTotals.roundOffPaisa),
      toRupees(computedTotals.grandTotalPaisa)
    );

    if (requestId) {
      db.prepare(`
        INSERT INTO idempotency_keys (request_id, shop_id, entity_type, entity_id, created_at)
        VALUES (?, ?, ?, ?, ?)
      `).run(requestId, shopId, 'invoice', invoiceId, now);
    }

    logAction(shopId, 'invoice', invoiceId, 'CREATE', { invoiceNumber }, actorUserId);
    bustHomeCache(shopId);

    return assembleInvoice(shopId, invoiceId);
  });
}

/**
 * Update an existing invoice (TRANSACTIONAL)
 * @param {string} shopId - Shop UUID
 * @param {string} invoiceId - Invoice UUID
 * @param {Object} aggregatePayload - Updated invoice aggregate
 * @param {string} actorUserId - User performing the action
 */
export function updateInvoice(shopId, invoiceId, aggregatePayload, actorUserId) {
  return transaction((db) => {
    const now = new Date().toISOString();

    const existing = db.prepare(`
      SELECT id FROM invoices WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
    `).get(invoiceId, shopId);

    if (!existing) {
      throw new Error('Invoice not found');
    }

    const computedTotals = calculateInvoiceTotals(
      aggregatePayload.items, aggregatePayload.placeOfSupply
    );

    const decomposed = decomposeInvoiceAggregate(aggregatePayload, { totals: computedTotals });

    // Sanitize customer snapshot fields to prevent XSS
    const sanitizedCustomerName = sanitizeString(decomposed.customerSnapshot.name);
    const sanitizedCustomerAddress = decomposed.customerSnapshot.address_json;

    // Sanitize item descriptions
    const sanitizedItems = decomposed.items.map(item => ({
      ...item,
      description: sanitizeString(item.description)
    }));

    db.prepare(`
      UPDATE invoices SET customer_id = ?, type = ?, status = ?, date = ?, due_date = ?,
          place_of_supply = ?, updated_at = ? WHERE id = ? AND shop_id = ?
    `).run(decomposed.invoice.customer_id, decomposed.invoice.type, decomposed.invoice.status,
      decomposed.invoice.date, decomposed.invoice.due_date,
      decomposed.invoice.place_of_supply, now, invoiceId, shopId);

    db.prepare('DELETE FROM invoice_customer_snapshot WHERE invoice_id = ?').run(invoiceId);
    db.prepare(`
      INSERT INTO invoice_customer_snapshot (invoice_id, name, phone, gstin, address_json)
      VALUES (?, ?, ?, ?, ?)
    `).run(invoiceId, sanitizedCustomerName, decomposed.customerSnapshot.phone,
      decomposed.customerSnapshot.gstin, sanitizedCustomerAddress);

    db.prepare('DELETE FROM invoice_items WHERE invoice_id = ?').run(invoiceId);
    const itemStmt = db.prepare(`
      INSERT INTO invoice_items (id, invoice_id, product_id, description, quantity, rate, tax_rate, weight_json, amount_json)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    sanitizedItems.forEach(item => {
      itemStmt.run(generateUUID(), invoiceId, item.product_id, item.description,
        item.quantity, item.rate, item.tax_rate, item.weight_json, item.amount_json);
    });

    db.prepare('DELETE FROM invoice_totals WHERE invoice_id = ?').run(invoiceId);
    db.prepare(`
      INSERT INTO invoice_totals (
        invoice_id,
        subtotal_paisa, tax_total_paisa, cgst_paisa, sgst_paisa, igst_paisa, round_off_paisa, grand_total_paisa,
        subtotal, tax_total, cgst, sgst, igst, round_off, grand_total
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      invoiceId,
      computedTotals.subtotalPaisa, computedTotals.taxTotalPaisa,
      computedTotals.cgstPaisa, computedTotals.sgstPaisa, computedTotals.igstPaisa,
      computedTotals.roundOffPaisa, computedTotals.grandTotalPaisa,
      toRupees(computedTotals.subtotalPaisa), toRupees(computedTotals.taxTotalPaisa),
      toRupees(computedTotals.cgstPaisa), toRupees(computedTotals.sgstPaisa),
      toRupees(computedTotals.igstPaisa), toRupees(computedTotals.roundOffPaisa),
      toRupees(computedTotals.grandTotalPaisa)
    );

    logAction(shopId, 'invoice', invoiceId, 'UPDATE', null, actorUserId);
    bustHomeCache(shopId);

    return assembleInvoice(shopId, invoiceId);
  });
}

/**
 * List all invoices for a shop (headers only)
 */
export function listInvoices(shopId) {
  const db = getDatabase();
  return db.prepare(`
    SELECT i.*, it.grand_total FROM invoices i
    LEFT JOIN invoice_totals it ON i.id = it.invoice_id
    WHERE i.shop_id = ? AND i.deleted_at IS NULL
    ORDER BY i.date DESC, i.created_at DESC
  `).all(shopId);
}

/**
 * Soft delete an invoice
 * @param {string} shopId - Shop UUID
 * @param {string} invoiceId - Invoice UUID
 * @param {string} actorUserId - User performing the action
 */
export function deleteInvoice(shopId, invoiceId, actorUserId) {
  const db = getDatabase();
  const result = db.prepare(`
    UPDATE invoices SET deleted_at = ? WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
  `).run(new Date().toISOString(), invoiceId, shopId);

  if (result.changes === 0) {
    throw new Error('Invoice not found or already deleted');
  }

  logAction(shopId, 'invoice', invoiceId, 'DELETE', null, actorUserId);
  bustHomeCache(shopId);
}

/**
 * Add a photo to an invoice
 */
export function addInvoicePhoto(shopId, invoiceId, filePath, checksum) {
  const db = getDatabase();
  const invoice = db.prepare('SELECT id FROM invoices WHERE id = ? AND shop_id = ?').get(invoiceId, shopId);
  if (!invoice) {
    throw new Error('Invoice not found');
  }

  const photoId = generateUUID();
  const now = new Date().toISOString();

  db.prepare(`
    INSERT INTO invoice_photos (id, invoice_id, file_path, checksum, created_at)
    VALUES (?, ?, ?, ?, ?)
  `).run(photoId, invoiceId, filePath, checksum, now);

  return { id: photoId, url: `/api/photos/${photoId}`, createdAt: now };
}

/**
 * Delete a photo from an invoice
 */
export function deleteInvoicePhoto(shopId, photoId) {
  const db = getDatabase();
  const photo = db.prepare(`
        SELECT ip.file_path FROM invoice_photos ip
        JOIN invoices i ON ip.invoice_id = i.id
        WHERE ip.id = ? AND i.shop_id = ?
    `).get(photoId, shopId);

  if (!photo) {
    throw new Error('Photo not found');
  }

  db.prepare('DELETE FROM invoice_photos WHERE id = ?').run(photoId);
  return photo.file_path;
}
</file>

<file path="src/services/paymentService.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase, transaction } from '../db/init.js';
import { generateUUID } from '../utils/uuid.js';
import { generatePaymentNumber } from './sequenceService.js';
import { updateCustomerBalance } from './customerService.js';
import { updateVendorBalance } from './vendorService.js';
import { logAction } from './auditService.js';
import { bustHomeCache } from '../routes/home.js';
import { sanitizeString } from '../utils/sanitize.js';

/**
 * Create a payment with allocations (TRANSACTIONAL)
 * @param {string} shopId - Shop UUID
 * @param {Object} data - Payment data
 * @param {string} actorUserId - User performing the action
 * @returns {Object} Created payment
 */
export function createPayment(shopId, data, actorUserId) {
    return transaction((db) => {
        const paymentId = generateUUID();
        const transactionNumber = generatePaymentNumber(shopId);
        const now = new Date().toISOString();

        const amountPaisa = Math.round(data.amount * 100);

        // Sanitize notes to prevent XSS
        const sanitizedNotes = sanitizeString(data.notes);

        db.prepare(`
      INSERT INTO payments (
        id, shop_id, transaction_number, date, type, party_type, party_id, amount_paisa, amount, mode, notes, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
            paymentId, shopId, transactionNumber, data.date, data.type,
            data.partyType, data.partyId, amountPaisa, data.amount, data.mode || null, sanitizedNotes || null, now
        );

        if (data.allocations && data.allocations.length > 0) {
            const allocStmt = db.prepare(`
        INSERT INTO payment_allocations (id, payment_id, invoice_id, amount)
        VALUES (?, ?, ?, ?)
      `);

            data.allocations.forEach(alloc => {
                allocStmt.run(generateUUID(), paymentId, alloc.invoiceId, alloc.amount);
            });

            data.allocations.forEach(alloc => {
                updateInvoiceStatus(db, shopId, alloc.invoiceId);
            });
        }

        if (data.partyType === 'CUSTOMER') {
            updateCustomerBalance(shopId, data.partyId);
        } else if (data.partyType === 'VENDOR') {
            updateVendorBalance(shopId, data.partyId);
        }

        logAction(shopId, 'payment', paymentId, 'CREATE', { transactionNumber }, actorUserId);
        bustHomeCache(shopId);

        return getPayment(shopId, paymentId);
    });
}

/**
 * Update invoice status based on payment allocations (internal helper)
 */
function updateInvoiceStatus(db, shopId, invoiceId) {
    const invoice = db.prepare(`
    SELECT it.grand_total_paisa FROM invoices i
    JOIN invoice_totals it ON i.id = it.invoice_id
    WHERE i.id = ? AND i.shop_id = ?
  `).get(invoiceId, shopId);

    if (!invoice) return;

    const allocated = db.prepare(`
    SELECT COALESCE(SUM(amount), 0) as total FROM payment_allocations WHERE invoice_id = ?
  `).get(invoiceId);

    // Convert allocated amount to paisa for comparison
    const totalPaidPaisa = Math.round(allocated.total * 100);
    const grandTotalPaisa = invoice.grand_total_paisa;

    let status;
    if (totalPaidPaisa >= grandTotalPaisa) {
        status = 'PAID';
    } else if (totalPaidPaisa > 0) {
        status = 'PARTIAL';
    } else {
        status = 'UNPAID';
    }

    db.prepare(`
    UPDATE invoices SET status = ?, updated_at = ? WHERE id = ? AND shop_id = ?
  `).run(status, new Date().toISOString(), invoiceId, shopId);
}

/**
 * Get a payment with allocations
 */
export function getPayment(shopId, paymentId) {
    const db = getDatabase();

    const payment = db.prepare(`
    SELECT * FROM payments WHERE id = ? AND shop_id = ?
  `).get(paymentId, shopId);

    if (!payment) return null;

    const allocations = db.prepare(`
    SELECT * FROM payment_allocations WHERE payment_id = ?
  `).all(paymentId);

    return { ...payment, allocations };
}

/**
 * List payments for a shop
 */
export function listPayments(shopId, filters = {}) {
    const db = getDatabase();

    let query = 'SELECT * FROM payments WHERE shop_id = ?';
    const params = [shopId];

    if (filters.partyId) {
        query += ' AND party_id = ?';
        params.push(filters.partyId);
    }

    if (filters.type) {
        query += ' AND type = ?';
        params.push(filters.type);
    }

    query += ' ORDER BY date DESC, created_at DESC';

    return db.prepare(query).all(...params);
}

/**
 * Delete a payment and recalculate balances
 * @param {string} shopId - Shop UUID
 * @param {string} paymentId - Payment UUID
 * @param {string} actorUserId - User performing the action
 */
export function deletePayment(shopId, paymentId, actorUserId) {
    return transaction((db) => {
        const payment = db.prepare('SELECT * FROM payments WHERE id = ? AND shop_id = ?').get(paymentId, shopId);

        if (!payment) {
            throw new Error('Payment not found');
        }

        const allocations = db.prepare(`
      SELECT invoice_id FROM payment_allocations WHERE payment_id = ?
    `).all(paymentId);

        db.prepare('DELETE FROM payment_allocations WHERE payment_id = ?').run(paymentId);
        db.prepare('DELETE FROM payments WHERE id = ?').run(paymentId);

        allocations.forEach(alloc => {
            updateInvoiceStatus(db, shopId, alloc.invoice_id);
        });

        if (payment.party_type === 'CUSTOMER') {
            updateCustomerBalance(shopId, payment.party_id);
        } else if (payment.party_type === 'VENDOR') {
            updateVendorBalance(shopId, payment.party_id);
        }

        logAction(shopId, 'payment', paymentId, 'DELETE', null, actorUserId);
        bustHomeCache(shopId);
    });
}
</file>

<file path="src/services/productService.js">
// SECURITY: All queries in this service MUST be scoped by shopId

import { getDatabase, transaction } from '../db/init.js';
import { generateUUID } from '../utils/uuid.js';
import { logAction } from './auditService.js';
import { sanitizeString } from '../utils/sanitize.js';

/**
 * Create a new product
 * @param {string} shopId - Shop UUID
 * @param {Object} data - Product data
 * @param {string} actorUserId - User performing the action
 */
export function createProduct(shopId, data, actorUserId) {
    return transaction((db) => {
        const productId = generateUUID();
        const now = new Date().toISOString();

        // Sanitize user input to prevent XSS
        const sanitizedName = sanitizeString(data.name);
        const sanitizedDescription = sanitizeString(data.description);
        const sanitizedVendorRef = sanitizeString(data.vendorRef);
        const sanitizedHallmarkCert = sanitizeString(data.hallmarkCert);

        db.prepare(`
      INSERT INTO products (
        id, shop_id, type, name, sku, barcode, hsn, category_id, subcategory_id,
        description, selling_price, purchase_price, tax_rate, unit,
        metal_json, gemstone_json, design_json, vendor_ref, procurement_date,
        hallmark_cert, launch_date, show_online, not_for_sale,
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
            productId,
            shopId,
            data.type,
            sanitizedName,
            data.sku || null,
            data.barcode || null,
            data.hsn || null,
            data.categoryId || null,
            data.subcategoryId || null,
            sanitizedDescription || null,
            data.sellingPrice || null,
            data.purchasePrice || null,
            data.taxRate || null,
            data.unit || null,
            data.metal ? JSON.stringify(data.metal) : null,
            data.gemstone ? JSON.stringify(data.gemstone) : null,
            data.design ? JSON.stringify(data.design) : null,
            sanitizedVendorRef || null,
            data.procurementDate || null,
            sanitizedHallmarkCert || null,
            data.launchDate || null,
            data.showOnline ? 1 : 0,
            data.notForSale ? 1 : 0,
            now,
            now
        );

        logAction(shopId, 'product', productId, 'CREATE', { name: sanitizedName }, actorUserId);

        return getProduct(shopId, productId);
    });
}

/**
 * Get a product with images
 * @param {string} shopId - Shop UUID
 * @param {string} productId - Product UUID
 */
export function getProduct(shopId, productId) {
    const db = getDatabase();

    const product = db.prepare(`
    SELECT * FROM products WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
  `).get(productId, shopId);

    if (!product) return null;

    const images = db.prepare(`
    SELECT * FROM product_images WHERE product_id = ? ORDER BY created_at
  `).all(productId);

    return {
        ...product,
        metal: product.metal_json ? JSON.parse(product.metal_json) : null,
        gemstone: product.gemstone_json ? JSON.parse(product.gemstone_json) : null,
        design: product.design_json ? JSON.parse(product.design_json) : null,
        images: images.map(img => ({
            id: img.id,
            url: `/api/photos/${img.id}`,
            createdAt: img.created_at
        }))
    };
}

/**
 * List products with optional filters (includes images)
 * @param {string} shopId - Shop UUID
 * @param {Object} filters - Optional filters
 */
export function listProducts(shopId, filters = {}) {
    const db = getDatabase();

    let query = 'SELECT * FROM products WHERE shop_id = ? AND deleted_at IS NULL';
    const params = [shopId];

    if (filters.type) {
        query += ' AND type = ?';
        params.push(filters.type);
    }

    if (filters.categoryId) {
        query += ' AND category_id = ?';
        params.push(filters.categoryId);
    }

    query += ' ORDER BY name';

    const products = db.prepare(query).all(...params);

    if (products.length === 0) {
        return [];
    }

    // Batch fetch all images for the returned products
    const productIds = products.map(p => p.id);
    const placeholders = productIds.map(() => '?').join(',');
    const allImages = db.prepare(`
        SELECT * FROM product_images 
        WHERE product_id IN (${placeholders}) 
        ORDER BY created_at
    `).all(...productIds);

    // Group images by product_id for efficient lookup
    const imagesByProductId = {};
    for (const img of allImages) {
        if (!imagesByProductId[img.product_id]) {
            imagesByProductId[img.product_id] = [];
        }
        imagesByProductId[img.product_id].push({
            id: img.id,
            url: `/api/photos/${img.id}`,
            createdAt: img.created_at
        });
    }

    return products.map(p => ({
        ...p,
        metal: p.metal_json ? JSON.parse(p.metal_json) : null,
        gemstone: p.gemstone_json ? JSON.parse(p.gemstone_json) : null,
        design: p.design_json ? JSON.parse(p.design_json) : null,
        images: imagesByProductId[p.id] || []
    }));
}

/**
 * Update a product
 * @param {string} shopId - Shop UUID
 * @param {string} productId - Product UUID
 * @param {Object} data - Update data
 * @param {string} actorUserId - User performing the action
 */
export function updateProduct(shopId, productId, data, actorUserId) {
    const db = getDatabase();
    const now = new Date().toISOString();

    // Sanitize user input to prevent XSS
    const sanitizedName = sanitizeString(data.name);
    const sanitizedDescription = sanitizeString(data.description);
    const sanitizedVendorRef = sanitizeString(data.vendorRef);
    const sanitizedHallmarkCert = sanitizeString(data.hallmarkCert);

    const result = db.prepare(`
    UPDATE products
    SET type = ?, name = ?, sku = ?, barcode = ?, hsn = ?, category_id = ?, 
        subcategory_id = ?, description = ?, selling_price = ?, purchase_price = ?,
        tax_rate = ?, unit = ?, metal_json = ?, gemstone_json = ?, design_json = ?,
        vendor_ref = ?, procurement_date = ?, hallmark_cert = ?, launch_date = ?,
        show_online = ?, not_for_sale = ?, updated_at = ?
    WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
  `).run(
        data.type,
        sanitizedName,
        data.sku || null,
        data.barcode || null,
        data.hsn || null,
        data.categoryId || null,
        data.subcategoryId || null,
        sanitizedDescription || null,
        data.sellingPrice || null,
        data.purchasePrice || null,
        data.taxRate || null,
        data.unit || null,
        data.metal ? JSON.stringify(data.metal) : null,
        data.gemstone ? JSON.stringify(data.gemstone) : null,
        data.design ? JSON.stringify(data.design) : null,
        sanitizedVendorRef || null,
        data.procurementDate || null,
        sanitizedHallmarkCert || null,
        data.launchDate || null,
        data.showOnline ? 1 : 0,
        data.notForSale ? 1 : 0,
        now,
        productId,
        shopId
    );

    if (result.changes === 0) {
        throw new Error('Product not found');
    }

    logAction(shopId, 'product', productId, 'UPDATE', null, actorUserId);

    return getProduct(shopId, productId);
}

/**
 * Soft delete a product
 * @param {string} shopId - Shop UUID
 * @param {string} productId - Product UUID
 * @param {string} actorUserId - User performing the action
 */
export function deleteProduct(shopId, productId, actorUserId) {
    const db = getDatabase();

    const result = db.prepare(`
    UPDATE products SET deleted_at = ? WHERE id = ? AND shop_id = ? AND deleted_at IS NULL
  `).run(new Date().toISOString(), productId, shopId);

    if (result.changes === 0) {
        throw new Error('Product not found or already deleted');
    }

    logAction(shopId, 'product', productId, 'DELETE', null, actorUserId);
}

/**
 * Add image to product
 * @param {string} shopId - Shop UUID (for validation)
 * @param {string} productId - Product UUID
 * @param {string} filePath - File path
 * @param {string} checksum - File checksum
 */
export function addProductImage(shopId, productId, filePath, checksum) {
    const db = getDatabase();

    // Verify product belongs to shop
    const product = db.prepare('SELECT id FROM products WHERE id = ? AND shop_id = ?').get(productId, shopId);
    if (!product) {
        throw new Error('Product not found');
    }

    const imageId = generateUUID();
    const now = new Date().toISOString();

    db.prepare(`
    INSERT INTO product_images (id, product_id, file_path, checksum, created_at)
    VALUES (?, ?, ?, ?, ?)
  `).run(imageId, productId, filePath, checksum, now);

    return { id: imageId, url: `/api/photos/${imageId}`, createdAt: now };
}

/**
 * Delete product image
 * @param {string} shopId - Shop UUID (for validation)
 * @param {string} imageId - Image UUID
 */
export function deleteProductImage(shopId, imageId) {
    const db = getDatabase();

    // Verify image belongs to a product in this shop
    const image = db.prepare(`
        SELECT pi.file_path FROM product_images pi
        JOIN products p ON pi.product_id = p.id
        WHERE pi.id = ? AND p.shop_id = ?
    `).get(imageId, shopId);

    if (!image) {
        throw new Error('Image not found');
    }

    db.prepare('DELETE FROM product_images WHERE id = ?').run(imageId);

    return image.file_path;
}
</file>

<file path="package.json">
{
  "name": "swipe-backend",
  "version": "1.0.0",
  "description": "Local-first backend service for Swipe Invoice application",
  "main": "src/server.js",
  "type": "module",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js",
    "test": "node --experimental-vm-modules node_modules/jest/bin/jest.js"
  },
  "keywords": [
    "invoice",
    "sqlite",
    "rest-api"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@adminjs/express": "^6.1.1",
    "adminjs": "^7.8.17",
    "archiver": "^7.0.1",
    "bcryptjs": "^2.4.3",
    "better-sqlite3": "^9.6.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^7.1.5",
    "express-session": "^1.18.2",
    "joi": "^17.11.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "pino": "^10.1.0",
    "pino-http": "^11.0.0",
    "pino-pretty": "^13.1.3",
    "rotating-file-stream": "^3.2.7",
    "sanitize-html": "^2.11.0",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "unzipper": "^0.12.3"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "nodemon": "^3.0.2"
  }
}
</file>

<file path="src/server.js">
import express from 'express';
import cors from 'cors';
import { networkInterfaces } from 'os';
import { config } from './config/index.js';
import { initDatabase, closeDatabase } from './db/init.js';
import { errorHandler, notFoundHandler, requestIdMiddleware } from './middleware/errorHandler.js';
import { logger, createHttpLogger } from './utils/logger.js';
import swaggerUi from 'swagger-ui-express';
import { swaggerSpec } from './config/swagger.js';
import { setupAdminJS } from './admin/index.js';
import { generalApiRateLimiter } from './middleware/rateLimiter.js';

// Import routes
import invoiceRoutes from './routes/invoices.js';
import customerRoutes from './routes/customers.js';
import productRoutes from './routes/products.js';
import paymentRoutes from './routes/payments.js';
import photoRoutes from './routes/photos.js';
import settingsRoutes from './routes/settings.js';
import categoryRoutes from './routes/categories.js';
import vendorRoutes from './routes/vendors.js';
import purchaseRoutes from './routes/purchases.js';
import attendanceRoutes from './routes/attendance.js';
import authRoutes from './routes/auth.js';
import setupRoutes from './routes/setup.js';
import homeRoutes from './routes/home.js';
import opsRoutes from './routes/ops.js';

// Initialize Express app
const app = express();

// Initialize database
logger.info('Initializing database...');
initDatabase();
logger.info('Database initialized successfully');

// CORS must come first
app.use(cors());

// AdminJS Panel - MUST be mounted BEFORE body-parser middleware
// to avoid middleware conflicts
(async () => {
    try {
        await setupAdminJS(app);
        logger.info({ adminPath: '/admin' }, 'AdminJS panel initialized');
    } catch (error) {
        logger.error({ error: error.message }, 'Failed to initialize AdminJS');
    }

    // Body-parser middleware (AFTER AdminJS to avoid conflicts)
    app.use(express.json({ limit: '50mb' }));
    app.use(express.urlencoded({ extended: true, limit: '50mb' }));
    app.use(requestIdMiddleware);
    app.use(createHttpLogger());

    // Health check
    app.get('/health', (req, res) => {
        res.json({
            status: 'ok',
            timestamp: new Date().toISOString(),
            environment: config.nodeEnv
        });
    });

    // Swagger UI
    app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

    // Apply general API rate limiting to all /api/* routes
    app.use('/api', generalApiRateLimiter);

    // API routes
    // Note: strictAuthRateLimiter is applied within authRoutes for sensitive endpoints
    app.use('/api/auth', authRoutes);
    app.use('/api/invoices', invoiceRoutes);
    app.use('/api/customers', customerRoutes);
    app.use('/api/products', productRoutes);
    app.use('/api/payments', paymentRoutes);
    app.use('/api/photos', photoRoutes);
    app.use('/api/settings', settingsRoutes);
    app.use('/api/categories', categoryRoutes);
    app.use('/api/vendors', vendorRoutes);
    app.use('/api/purchases', purchaseRoutes);
    app.use('/api/attendance', attendanceRoutes);
    app.use('/api/setup', setupRoutes);
    app.use('/api/home', homeRoutes);
    app.use('/api/ops', opsRoutes);

    // 404 handler (must come after all routes including AdminJS)
    app.use(notFoundHandler);

    // Global error handler (must be last)
    app.use(errorHandler);

    // Helper to get local LAN IP address
    function getLocalIPAddress() {
        const nets = networkInterfaces();
        for (const name of Object.keys(nets)) {
            for (const net of nets[name]) {
                // Skip internal and non-IPv4 addresses
                if (net.family === 'IPv4' && !net.internal) {
                    return net.address;
                }
            }
        }
        return null;
    }

    // Start server
    const server = app.listen(config.port, config.host, () => {
        const lanIP = getLocalIPAddress();
        const lanUrl = lanIP ? `http://${lanIP}:${config.port}` : 'unavailable';

        logger.info({
            environment: config.nodeEnv,
            host: config.host,
            port: config.port,
            database: config.databasePath,
            storage: config.storagePath,
            localUrl: `http://localhost:${config.port}`,
            lanUrl: lanUrl,
            apiBase: `http://localhost:${config.port}/api`,
            health: `http://localhost:${config.port}/health`,
            apiDocs: `http://localhost:${config.port}/api-docs`,
            adminPanel: `http://localhost:${config.port}/admin`
        }, '🚀 Swipe Backend Server Running');

        if (lanIP) {
            logger.info({ lanIP, lanHealth: `${lanUrl}/health`, lanApiDocs: `${lanUrl}/api-docs` }, '📱 LAN Access Available');
        }
    });

    // Graceful shutdown
    process.on('SIGTERM', shutdown);
    process.on('SIGINT', shutdown);

    function shutdown() {
        logger.info('Shutting down gracefully...');

        server.close(() => {
            logger.info('HTTP server closed');
            closeDatabase();
            process.exit(0);
        });

        // Force shutdown after 10 seconds
        setTimeout(() => {
            logger.error('Could not close connections in time, forcefully shutting down');
            process.exit(1);
        }, 10000);
    }
})();
</file>

<file path="integration.md">
# Swipe Backend Integration Guide

Complete API documentation for frontend integration with the Swipe Store Backend.

## Connection Details

| Setting | Value |
|---------|-------|
| **Base URL** | `http://localhost:3000/api` |
| **Health Check** | `GET /health` |
| **Content-Type** | `application/json` |

---

## Security Features

### Rate Limiting

The API implements rate limiting to protect against abuse:

**Auth Endpoints** (`/api/auth/*`):
- Limit: **10 requests per 10 minutes** per IP address
- Applies to: OTP requests, login, verification
- Headers: `RateLimit-*` standard headers included

**General API** (`/api/*`):
- Limit: **100 requests per 15 minutes** per IP address
- Applies to: All authenticated endpoints
- AdminJS routes are excluded from rate limiting

**Rate Limit Response (429):**
```json
{
  "error": "Too many requests from this IP, please try again later.",
  "requestId": "uuid"
}
```

The response includes a `Retry-After` header indicating seconds until the limit resets.

### Input Sanitization

All user-submitted text fields are automatically sanitized to prevent stored XSS attacks:

**Sanitized Fields:**
- Customer/Vendor: `name`, `address`
- Product: `name`, `description`, `vendorRef`, `hallmarkCert`
- Invoice: Customer snapshot `name`, item `description`
- Payment: `notes`
- Category: `name`

**Not Sanitized** (validated by type):
- IDs, UUIDs, numbers, dates, phone, email, GSTIN, enums, SKUs, barcodes

HTML tags are stripped from sanitized fields before storage. This happens transparently; no changes are required to request/response formats.

### Database Resilience

The SQLite database is configured with:
- **WAL mode** for concurrent read/write performance
- **5-second busy timeout** to automatically handle database lock contention
- Automatic retries when multiple users write simultaneously



---

## Multi-User Architecture

### Shop (Tenant) Model
- All business data belongs to a **Shop**
- Users authenticate and operate within exactly one shop
- Data is completely isolated between shops

### Shop Bootstrap (Initial Setup)

Before any user can login, a shop must be created via the setup API:

#### GET `/api/setup/status`
Check if shop exists.
```json
// Response
{ "setupComplete": false, "shop": null }
```

#### POST `/api/setup/bootstrap`
Create shop and admin user (one-time setup).
```json
// Request
{
  "shopName": "My Shop",
  "adminPhone": "9876543210",
  "setupSecret": "your-setup-secret"
}

// Response
{
  "success": true,
  "shop": { "id": "shop-uuid", "name": "My Shop" },
  "user": { "id": "user-uuid", "phone": "9876543210", "role": "ADMIN" }
}
```

> **Note:** `setupSecret` must match the `SETUP_SECRET` environment variable.

### Post-Setup Login Behavior
- **Registered users** → Normal OTP login
- **Unregistered users** → `403: User not registered. Contact your shop admin.`
- **Shops are never auto-created** during login

---

## Authentication

Phone-based OTP authentication with JWT tokens.

### POST `/api/auth/request-otp`
Request OTP for a phone number.
```json
// Request
{ "phone": "9876543210" }

// Response
{ "success": true, "message": "OTP sent successfully", "phone": "9876543210" }
```

### POST `/api/auth/verify-otp` or `/api/auth/login`
Verify OTP and get JWT token. **Dev OTP: `111111`**
```json
// Request
{ "phone": "9876543210", "otp": "111111" }

// Response
{
  "token": "eyJhbGciOiJIUzI1NiIs...",
  "user": { 
    "id": "uuid", 
    "phone": "9876543210", 
    "name": "John",
    "role": "ADMIN",
    "shopId": "shop-uuid"
  }
}
```

### GET `/api/auth/me` *(Auth Required)*
Get current user info with shop details.
```json
// Response
{
  "id": "user-uuid",
  "phone": "9876543210",
  "name": "John",
  "role": "ADMIN",
  "shop": {
    "id": "shop-uuid",
    "name": "My Shop"
  }
}
```

### JWT Token Structure
```json
{
  "userId": "user-uuid",
  "shopId": "shop-uuid",
  "role": "ADMIN"
}
```

---

## User Management (ADMIN Only)

### GET `/api/auth/users`
List all users in your shop.
```json
// Response
[
  { "id": "uuid", "phone": "9876543210", "name": "John", "role": "ADMIN", "created_at": "..." }
]
```

### POST `/api/auth/users`
Create a new user in your shop.
```json
// Request
{ "phone": "1111111111", "name": "Sales Person", "role": "SALES" }

// Response
{ "id": "uuid", "phone": "1111111111", "name": "Sales Person", "role": "SALES", "shop": {...} }
```

> **Note:** Role defaults to `SALES` if not specified.

---

## Role Permissions

| Action | ADMIN | SALES |
|--------|-------|-------|
| Create (customers, products, etc.) | ✅ | ✅ |
| Read all data | ✅ | ✅ |
| Update records | ✅ | ✅ |
| Delete records | ✅ | ❌ |
| Change settings | ✅ | ❌ |
| Manage users | ✅ | ❌ |

---

## LAN Multi-User Setup

Run one backend on the local network:
```bash
npm start
# Server shows LAN URL: http://192.168.x.x:3000
```

Multiple devices can connect:
1. All devices point to the same backend URL
2. Each user logs in with their phone number
3. First login creates the shop; subsequent logins join as users (via admin invite)
4. All data syncs in real-time across devices

---

## Key Concepts

### Aggregate Objects
For entities like **Invoices**, you send/receive the complete object. The backend atomically handles the underlying tables.

### Idempotency Keys
Use `X-Request-Id: <UUID>` header on `POST /api/invoices` to prevent duplicate records on network retries.

### Server-Side Authority
The backend **always** recomputes totals, taxes, and balances. Client-sent calculations are ignored.

---

## Invoices

### GET `/api/invoices`
List all invoice headers.

### GET `/api/invoices/:id`
Get full invoice aggregate with items, totals, customer snapshot, and photos.

### POST `/api/invoices`
Create invoice. Supports `X-Request-Id` header for idempotency.
```json
{
  "customerId": "uuid (optional)",
  "type": "INVOICE",  // INVOICE | PROFORMA | LENDING
  "status": "UNPAID", // PAID | PARTIAL | UNPAID | PENDING
  "date": "2025-12-27",
  "dueDate": "2026-01-27",
  "placeOfSupply": "Karnataka",
  "customer": {
    "name": "John Doe",
    "phone": "+91...",
    "gstin": "...",
    "address": { "line1": "...", "pincode": "..." }
  },
  "items": [{
    "productId": "uuid (optional)",
    "description": "Gold Ring 22k",
    "quantity": 1,
    "rate": 65000,
    "taxRate": 3,
    "weight": { "gross": 5.2, "net": 4.8 },
    "amount": { "makingCharges": 500, "stoneCharges": 200 }
  }]
}
```
**Response includes server-computed `totals`:** subtotal, taxTotal, cgst, sgst, igst, roundOff, grandTotal.

### PUT `/api/invoices/:id`
Full replacement update.

### DELETE `/api/invoices/:id`
Soft delete.

### POST `/api/invoices/:id/photos`
Upload photo (multipart/form-data, field: `photo`).

**Limits:**
- Max file size: **5MB**
- Allowed types: `image/*` only

**Error Responses:**
```json
// 400: File too large
{ "error": "File too large. Maximum size is 5MB" }

// 400: Invalid type
{ "error": "Only image files are allowed" }
```

### DELETE `/api/invoices/:invoiceId/photos/:photoId`

---

## Customers

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/customers` | List all |
| GET | `/api/customers/:id` | Get one (includes `balance`) |
| POST | `/api/customers` | Create |
| PUT | `/api/customers/:id` | Update |
| DELETE | `/api/customers/:id` | Soft delete |

### Request (POST/PUT)
```json
{
  "name": "Jane Smith",
  "gstin": "...",
  "phone": "9999999999",
  "email": "jane@example.com",
  "address": { "line1": "...", "city": "...", "pincode": "..." }
}
```

### Response (all endpoints)
```json
{
  "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "name": "Jane Smith",
  "phone": "9999999999",
  "email": "jane@example.com",
  "gstin": "...",
  "balance": 0,
  "address": { "line1": "...", "city": "...", "pincode": "..." },
  "created_at": "2025-12-28T10:00:00.000Z",
  "updated_at": "2025-12-28T10:00:00.000Z"
}
```

> ⚠️ **IMPORTANT:** The `id` field is a **UUID generated by the backend**. Frontend must store and use this UUID for all subsequent operations (payments, invoices, etc.). Do NOT use local/IndexedDB IDs.

---

## Products

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/products` | List with images (filters: `?type=product`, `?categoryId=uuid`) |
| GET | `/api/products/:id` | Get with images |
| POST | `/api/products` | Create |
| PUT | `/api/products/:id` | Update (does NOT affect images) |
| DELETE | `/api/products/:id` | Soft delete |
| POST | `/api/products/:id/images` | Upload image (multipart) |
| DELETE | `/api/products/:productId/images/:imageId` | Delete image |

### Product JSON Schema
```json
{
  "type": "product",
  "name": "Diamond Earring",
  "sku": "DE-001",
  "sellingPrice": 120000,
  "taxRate": 3,
  "metal": { "purity": "18k", "type": "Rose Gold" },
  "gemstone": { "type": "Diamond", "carat": 0.5 }
}
```

### ⚠️ Image Handling (Important)

**Images are managed separately from product data.** The `PUT /api/products/:id` endpoint does **NOT** accept or modify images. Existing images persist across product updates.

#### Workflow
1. **Create/Update product** → `POST` or `PUT /api/products/:id` (no images in body)
2. **Add image** → `POST /api/products/:id/images` (multipart/form-data)
3. **Remove image** → `DELETE /api/products/:productId/images/:imageId`

#### Upload Request
```http
POST /api/products/:id/images
Content-Type: multipart/form-data

image: <binary file>   ← field name must be "image"
```

**Limits:**
- Max file size: **5MB**
- Allowed types: `image/*` only

**Error Responses:**
```json
// 400: File too large
{ "error": "File too large. Maximum size is 5MB" }

// 400: Invalid type
{ "error": "Only image files are allowed" }
```

#### Response from GET `/api/products/:id`
```json
{
  "id": "uuid",
  "name": "Diamond Earring",
  ...
  "images": [
    { "id": "image-uuid", "url": "/api/photos/image-uuid", "createdAt": "..." }
  ]
}
```

Images are linked via `product_id` foreign key and returned automatically when fetching a product.

---

## Payments

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/payments` | List (filters: `?partyId=uuid`, `?type=IN|OUT`) |
| GET | `/api/payments/:id` | Get with allocations |
| POST | `/api/payments` | Create (auto-updates invoice status & balance) |
| DELETE | `/api/payments/:id` | Delete (recalculates balances) |

```json
{
  "type": "IN",
  "partyType": "CUSTOMER",
  "partyId": "uuid",
  "amount": 10000,
  "date": "2025-12-27",
  "mode": "UPI",
  "allocations": [
    { "invoiceId": "uuid", "amount": 10000 }
  ]
}
```

---

## Categories

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/categories` | List all with subcategories |
| GET | `/api/categories/:id` | Get one |
| POST | `/api/categories` | Create: `{ "name": "Gold Jewelry", "type": "product" }` |
| PUT | `/api/categories/:id` | Update |
| DELETE | `/api/categories/:id` | Delete (cascades subcategories) |
| POST | `/api/categories/:id/subcategories` | Add: `{ "name": "Rings" }` |
| DELETE | `/api/categories/:categoryId/subcategories/:subcategoryId` | Delete |

---

## Vendors

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/vendors` | List all |
| GET | `/api/vendors/:id` | Get one (includes `balance`) |
| POST | `/api/vendors` | Create |
| PUT | `/api/vendors/:id` | Update |
| DELETE | `/api/vendors/:id` | Soft delete |

Same request/response schema as Customers.

> ⚠️ **IMPORTANT:** The `id` field is a **UUID generated by the backend**. Use this UUID for payments and purchases.

---

## Purchases

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/purchases` | List (filters: `?vendorId=uuid`, `?status=PAID|UNPAID`) |
| GET | `/api/purchases/:id` | Get with vendor info |
| POST | `/api/purchases` | Create |
| PUT | `/api/purchases/:id` | Update |
| DELETE | `/api/purchases/:id` | Soft delete |

```json
{
  "vendorId": "uuid",
  "date": "2025-12-27",
  "dueDate": "2026-01-27",
  "status": "UNPAID"
}
```

---

## Attendance

| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | `/api/attendance/login` | Log login: `{ "userId": "uuid" }` |
| POST | `/api/attendance/logout` | Log logout: `{ "logId": "uuid" }` |
| GET | `/api/attendance/user/:userId` | History (`?limit=30`) |
| GET | `/api/attendance/user/:userId/date/:date` | Specific date |
| GET | `/api/attendance/date/:date` | All users (admin) |

---

## Photos

### GET `/api/photos/:id` *(Auth Required)*

Serve image file directly. Use photo ID from invoice/product responses.

**Security:**
- Requires authentication (`Authorization: Bearer <token>`)
- Shop-scoped: Only returns photos belonging to your shop
- Returns 401 if no token, 404 if photo not found or belongs to another shop

**Response:**
- `200 OK`: Binary image data with appropriate `Content-Type` header
- `401 Unauthorized`: Missing or invalid token
- `404 Not Found`: Photo doesn't exist or belongs to another shop

> ⚠️ **IMPORTANT:** Browser `<img src="...">` tags do NOT send `Authorization` headers automatically. You must load images programmatically with the auth header.

**Frontend Integration (JavaScript/Web):**
```javascript
// Load authenticated image and convert to displayable URL
async function loadAuthenticatedImage(photoId) {
  const response = await fetch(`/api/photos/${photoId}`, {
    headers: {
      'Authorization': `Bearer ${getToken()}`
    }
  });
  
  if (!response.ok) {
    throw new Error(`Failed to load image: ${response.status}`);
  }
  
  const blob = await response.blob();
  return URL.createObjectURL(blob);
}

// Usage
const imageUrl = await loadAuthenticatedImage('photo-uuid');
document.getElementById('my-image').src = imageUrl;

// Remember to revoke when done to prevent memory leaks
URL.revokeObjectURL(imageUrl);
```

**Frontend Integration (Swift/iOS):**
```swift
func loadAuthenticatedImage(photoId: String, token: String) async throws -> UIImage {
    var request = URLRequest(url: URL(string: "\(baseURL)/api/photos/\(photoId)")!)
    request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
    
    let (data, response) = try await URLSession.shared.data(for: request)
    
    guard let httpResponse = response as? HTTPURLResponse,
          httpResponse.statusCode == 200,
          let image = UIImage(data: data) else {
        throw ImageError.loadFailed
    }
    
    return image
}
```

**React Native / Expo:**
```javascript
// Use Image component with headers prop
<Image
  source={{
    uri: `/api/photos/${photoId}`,
    headers: { Authorization: `Bearer ${token}` }
  }}
/>
```

---

## Settings

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/settings` | Get all |
| GET | `/api/settings/:key` | Get one |
| PUT | `/api/settings/:key` | Set: `{ "value": ... }` |

---

## Home Snapshot

The home snapshot endpoint provides aggregated metrics for the home screen. All business logic is backend-owned.

### GET `/api/home/snapshot` *(Auth Required)*

Returns complete home screen data as a single deterministic snapshot.

**Response:**
```json
{
  "snapshotVersion": 1,
  "businessPulse": {
    "amountReceivedThisWeek": 50000,
    "percentChangeWoW": 25.5,
    "paymentsCompleted": 3
  },
  "primaryAction": {
    "mostUsed": "INVOICE"
  },
  "recentActivity": [
    {
      "type": "INVOICE",
      "title": "Overdue: INV-001",
      "subtitle": "Customer Name",
      "amount": 10000,
      "status": "OVERDUE",
      "date": "2025-12-15",
      "entityId": "invoice-uuid"
    }
  ],
  "riskSummary": {
    "unpaidInvoicesCount": 5,
    "unpaidAmount": 125000
  },
  "momentum": {
    "invoiceStreakDays": 7,
    "totalSentThisWeek": 12
  },
  "generatedAt": "2026-01-03T13:52:00.000Z"
}
```

**Field Descriptions:**

- `snapshotVersion`: Schema version (currently 1)
- `businessPulse`: Weekly payment metrics with WoW comparison
- `primaryAction.mostUsed`: `"INVOICE"` | `"PURCHASE"` | `"EXPENSE"` (based on last 30 days)
- `recentActivity`: Curated cards (max 3):
  - First: Oldest overdue invoice (if any)
  - Second: Last paid invoice (if any)
  - Third: Risk summary OR recent creation
- `riskSummary`: Aggregated unpaid/partial invoices
- `momentum.invoiceStreakDays`: Consecutive days with ≥1 invoice
- `generatedAt`: ISO timestamp of snapshot generation

**Caching:**

- Snapshots are cached server-side for 5 minutes
- Cache is automatically invalidated on invoice/payment/purchase mutations
- Subsequent calls within 5 minutes return cached data

**UI Guidelines:**

- Call once on home screen mount
- Render sections conditionally (check for empty arrays/zero counts)
- **NEVER** compute totals, percentages, or filters in UI
- All business logic is backend-owned


---

## Operations (Backup & Restore)

The operations endpoints provide manual backup functionality for local data safety.

### POST `/api/ops/backup` *(Auth Required)*

Create a full backup of the database and file storage as a single ZIP file.

**Security:**
- Requires authentication
- Prevents concurrent backups (409 Conflict if backup already running)
- Logs all backup creation to audit trail

**Request:**
```http
POST /api/ops/backup
Authorization: Bearer <token>
Content-Type: application/json
```

**Response (200 OK):**
```json
{
  "success": true,
  "filename": "swipe_backup_2026-01-03T14-30-00-000Z.zip",
  "sizeBytes": 1234567,
  "createdAt": "2026-01-03T14:30:00.000Z"
}
```

**Response (409 Conflict):**
```json
{
  "error": "Backup already in progress",
  "requestId": "uuid"
}
```

**Backup Contents:**
- SQLite database (`swipe.db`)
- All file storage (`storage/photos/`)
- Packaged as a single timestamped ZIP file

**Storage Location:** `storage/backups/`

---

### GET `/api/ops/backup/:filename` *(Auth Required)*

Download a previously created backup ZIP file.

**Security:**
- Requires authentication
- Strict filename validation (prevents path traversal attacks)
- Only allows filenames matching pattern: `swipe_backup_<timestamp>.zip`

**Request:**
```http
GET /api/ops/backup/swipe_backup_2026-01-03T14-30-00-000Z.zip
Authorization: Bearer <token>
```

**Response (200 OK):**
- Binary ZIP file download
- Content-Disposition header set for automatic download

**Response (400 Bad Request):**
```json
{
  "error": "Invalid backup filename",
  "requestId": "uuid"
}
```

**Response (404 Not Found):**
```json
{
  "error": "Backup file not found",
  "requestId": "uuid"
}
```

**Frontend Integration Example:**
```javascript
// 1. Create backup
const createBackup = async () => {
  const response = await fetch('/api/ops/backup', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  });
  
  if (response.status === 409) {
    alert('Backup already in progress');
    return;
  }
  
  const { filename } = await response.json();
  
  // 2. Download using fetch (Authorization header required)
  const downloadResponse = await fetch(`/api/ops/backup/${filename}`, {
    headers: { 'Authorization': `Bearer ${token}` }
  });
  
  if (!downloadResponse.ok) {
    throw new Error('Download failed');
  }
  
  // 3. Trigger browser download from blob
  const blob = await downloadResponse.blob();
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
};
```

> ⚠️ **IMPORTANT:** Do NOT use `window.location.href` for the download. Browser navigation does not include the `Authorization` header, causing a 401 error. Always use `fetch()` with the token.

**Best Practices:**
1. Show loading state during backup creation (can take several seconds)
2. Handle 409 errors gracefully (inform user, disable button)
3. Automatically trigger download on successful backup creation
4. Consider debouncing backup button clicks

---

### POST `/api/ops/restore` *(ADMIN Only)*

Restore database and file storage from a previously downloaded backup ZIP file.

> ⚠️ **CRITICAL:** This is a **destructive operation**. All current data will be replaced with backup contents. The server will **shut down** after successful restore and must be restarted manually.

**Security:**
- Requires authentication with **ADMIN role**
- Prevents concurrent restores (409 Conflict)
- Cannot run while backup is in progress
- Strict ZIP validation (path traversal prevention)
- Creates emergency backup before restore

**Request:**
```http
POST /api/ops/restore
Authorization: Bearer <token>
Content-Type: multipart/form-data

backup: <ZIP file>
```

**Limits:**
- Max file size: **100MB**
- Allowed types: `.zip` only

**Response (200 OK):**
```json
{
  "success": true,
  "restartRequired": true,
  "photosRestored": 42,
  "emergencyBackupPath": "emergency_pre_restore_2026-01-05T15-30-00-000Z.db",
  "restoredAt": "2026-01-05T15:30:00.000Z"
}
```

> **Note:** After this response, the server will exit. Restart required.

**Response (400 Bad Request):**
```json
{ "error": "Invalid backup: swipe.db not found at root", "requestId": "uuid" }
```

**Response (403 Forbidden):**
```json
{ "error": "Admin access required for restore operations", "requestId": "uuid" }
```

**Response (409 Conflict):**
```json
{ "error": "Restore already in progress", "requestId": "uuid" }
```

**Response (415 Unsupported Media Type):**
```json
{ "error": "Only ZIP files are allowed", "requestId": "uuid" }
```

**Frontend Integration Example:**
```javascript
const restoreFromBackup = async (file) => {
  const formData = new FormData();
  formData.append('backup', file);
  
  const response = await fetch('/api/ops/restore', {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${token}` },
    body: formData
  });
  
  if (response.status === 403) {
    alert('Admin access required');
    return;
  }
  
  if (!response.ok) {
    const { error } = await response.json();
    throw new Error(error);
  }
  
  const result = await response.json();
  alert(`Restore complete! ${result.photosRestored} photos restored. Server will restart.`);
  // Connection will be lost - handle reconnection logic
};
```

**Best Practices:**
1. Show prominent warning before restore (data loss)
2. Require confirmation dialog
3. Handle connection loss after successful restore
4. Implement automatic reconnection with retry logic


---

## Error Responses


```json
{
  "error": "Short description",
  "details": {},
  "requestId": "uuid"
}
```

| Code | Meaning |
|------|---------|
| 400 | Validation failed |
| 401 | Auth required |
| 403 | Forbidden / Invalid token |
| 404 | Not found |
| 500 | Server error |

---

## Best Practices

1. **Dates:** Use ISO 8601 format (`YYYY-MM-DD`)
2. **Auth:** Include `Authorization: Bearer <token>` header for protected routes
3. **Idempotency:** Use `X-Request-Id` header for invoice creation
4. **Balances:** Always read balances from server; never calculate client-side
</file>

</files>
